{"pages":[{"title":"categories","text":"","path":"categories/index.html","date":"10-13","excerpt":""},{"title":"搜索功能的必须步骤","text":"","path":"搜索功能的必须步骤/index.html","date":"09-10","excerpt":""},{"title":"about","text":"","path":"about/index.html","date":"10-13","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"10-13","excerpt":""}],"posts":[{"title":"","text":"Hadoop产生的背景 Hadoop是啥 HADOOP在大数据、云计算中的位置和关系 Hadoop的技术应用 HADOOP生态圈以及各组成部分的简介 获取数据的三种方式 国内HADOOP的就业情况分析 1、HADOOP就业整体情况 2、 HADOOP就业职位要求 正文 Hadoop产生的背景\\1. HADOOP最早起源于Nutch。Nutch的设计目标是构建一个大型的全网搜索引擎，包括网页抓取、索引、查询等功能，但随着抓取网页数量的增加，遇到了严重的可扩展性问题——如何解决数十亿网页的存储和索引问题。 \\2. 2003年开始谷歌陆续发表的三篇论文为该问题提供了可行的解决方案。 ——分布式文件系统（GFS），可用于处理海量网页的存储 ——分布式计算框架MAPREDUCE，可用于处理海量网页的索引计算问题。 ——BigTable 数据库：OLTP 联机事务处理 Online Transaction Processing 增删改 OLAP 联机分析处理 Online Analysis Processing 查询 真正的作用：提供了一种可以在超大数据集中进行实时CRUD操作的功能 3.Nutch的开发人员完成了相应的开源实现HDFS和MAPREDUCE，并从Nutch中剥离成为独立项目HADOOP，到2008年1月，HADOOP成为Apache顶级项目，迎来了它的快速发展期。 回到顶部 Hadoop是啥Hadoop的官网：http://hadoop.apache.org/ 1、Hadoop是Apache旗下的一套开源软件平台 2、Hadoop提供的功能：利用服务器集群，根据户自定义业逻辑对海量数进行分布式处理 3、Hadoop的核心组件： 1）Hadoop Common：支持其他Hadoop模块的常用工具。 2) Hadoop分布式文件系统（HDFS™）：一种分布式文件系统，可提供对应用程序数据的高吞吐量访问。 3) Hadoop YARN：作业调度和集群资源管理的框架。 4) Hadoop MapReduce：一种用于并行处理大型数据集的基于YARN的系统。 大数据的处理主要就是存储和计算。 如果说安装hadoop集群，其实就是安装了两个东西： 一个操作系统YARN 和 一个文件系统HDFS。其实MapReduce就是运行在YARN之上的应用。 操作系统 文件系统 应用程序win7 NTFS QQ，WeChatYARN HDFS MapReduce 4、hadoop的概念： 狭义上： 就是apache的一个顶级项目：apahce hadoop 广义上: 就是指以hadoop为核心的整个大数据处理体系 5、Apache的其他Hadoop相关项目包括： Ambari™：一种用于供应，管理和监控Apache Hadoop集群的基于Web的工具，其中包括对Hadoop HDFS，Hadoop MapReduce，Hive，HCatalog，HBase，ZooKeeper，Oozie，Pig和Sqoop的支持。Ambari还提供了一个用于查看群集运行状况的仪表板，例如热图和可以直观地查看MapReduce，Pig和Hive应用程序的功能，以及以用户友好的方式诊断其性能特征的功能。 Avro™：数据序列化系统。 Cassandra™：无单点故障的可扩展多主数据库。 Chukwa™：管理大型分布式系统的数据收集系统。 HBase™：可扩展的分布式数据库，支持大型表格的结构化数据存储。 Hive™：提供数据汇总和即席查询的数据仓库基础架构。 Mahout™：可扩展的机器学习和数据挖掘库。 Pig™：用于并行计算的高级数据流语言和执行框架。 Spark™：用于Hadoop数据的快速和通用计算引擎。Spark提供了一个简单而富有表现力的编程模型，它支持广泛的应用程序，包括ETL，机器学习，流处理和图计算。 Tez™：一种基于Hadoop YARN的通用数据流编程框架，它提供了一个强大且灵活的引擎，可执行任意DAG任务来处理批处理和交互式用例的数据。Hado™，Pig™和Hadoop生态系统中的其他框架以及其他商业软件（例如ETL工具）正在采用Tez来替代Hadoop™MapReduce作为底层执行引擎。 ZooKeeper™：分布式应用程序的高性能协调服务。 回到顶部 HADOOP在大数据、云计算中的位置和关系1、云计算是分布式计算、并行计算、网格计算、多核计算、网络存储、虚拟化、负载均衡等传统计算机技术和互联网技术融合发展的产物。借助IaaS(基础设施即服务)、PaaS(平台即服务)、SaaS（软件即服务）等业务模式，把强大的计算能力提供给终端用户。1、 2、现阶段，云计算的两大底层支撑技术为“虚拟化”和“大数据技术” 3、 而HADOOP则是云计算的PaaS层的解决方案之一，并不等同于PaaS，更不等同于云计算本身。 回到顶部 Hadoop的技术应用HADOOP应用于数据服务基础平台建设 HADOOP用于用户画像 该图是中国电信的用户画像标签体系。 HADOOP用于网站点击流日志**数据**挖掘 总结：hadoop并不会跟某个具体的行业或者某个具体的业务挂钩，它只是一种用来做海量数据分析处理的工具。 回到顶部 HADOOP生态圈以及各组成部分的简介 重点组件： HDFS：Hadoop的分布式文件存储系统。 MapReduce：Hadoop的分布式程序运算框架，也可以叫做一种编程模型。 Hive：基于Hadoop的类SQL数据仓库工具 Hbase：基于Hadoop的列式分布式NoSQL数据库 ZooKeeper：分布式协调服务组件 Mahout：基于MapReduce/Flink/Spark等分布式运算框架的机器学习算法库 Oozie/Azkaban：工作流调度引擎 Sqoop：数据迁入迁出工具 Flume：日志采集工具 回到顶部 获取数据的三种方式1、自己公司收集的数据–日志 或者 数据库中的数据 2、有一些数据可以通过爬虫从网络中进行爬取 3、从第三方机构购买 回到顶部 国内HADOOP的就业情况分析1、HADOOP就业整体情况A. 大数据产业已纳入国家十三五规划 B. 各大城市都在进行智慧城市项目建设，而智慧城市的根基就是大数据综合平台 C. 互联网时代数据的种类，增长都呈现爆发式增长，各行业对数据的价值日益重视 D. 相对于传统JAVAEE技术领域来说，大数据领域的人才相对稀缺 E. 随着现代社会的发展，数据处理和数据挖掘的重要性只会增不会减，因此，大数据技术是一个尚在蓬勃发展且具有长远前景的领域 2、 HADOOP就业职位要求大数据是个复合专业，包括应用开发、软件平台、算法、数据挖掘等，因此，大数据技术领域的就业选择是多样的，但就HADOOP而言，通常都需要具备以下技能或知识： 硬实力 A. HADOOP分布式集群的平台搭建 B. HADOOP分布式文件系统HDFS的原理理解及使用 C. HADOOP分布式运算框架MAPREDUCE的原理理解及编程 D. Hive数据仓库工具的熟练应用 E. Flume、sqoop、oozie等辅助工具的熟练使用 F. Shell/python等脚本语言的开发能力 软实力 A. 解决问题的能力（调试，阅读文档） B. 沟通协调能力（寻求帮助） C. 学习提升自己的能力（自我提高） D. 组织管控能力（管理能力）","path":"2019/02/18/hadoop-fa-zhan-bei-jing/","date":"02-18","excerpt":""},{"title":"oracle 回收站","text":"回收站概念 从ORACLE 10g开始，引入了一个叫回收站(Recycle Bin)的概念。它的全称叫Tablespace RecycleBin。回收站实际是一个逻辑容器（逻辑区域），原理有点类似于WINDOW系统的回收站。它以表空间中现有已经分配的空间为基础，而不是从表空间上物理划出一个固定区域用作回收站。这意味着回收站和表空间中的对象共用存储区域、系统没有给回收站预留空间。因此，当表被DROP后，如果可用空间充足，并且没有对回收站进行清理，那么被DROP掉的对象会一直存在回收站中，但是如果可用空间紧张的情况下，数据库会根据先进先出的顺序覆盖RecycleBin中的对象。所以回收站机制也不是百分百的保险机制。另外从原理上来说它就是一个数据字典表，放置用户Drop掉的数据库对象信息。用户进行Drop操作的对象并没有真正被数据库删除，仍然会占用空间。除非是由于用户手工进行Purge或者因为存储空间不够而被数据库清掉。数据库有了这样的功能，能够减少很多不必要的麻烦。当用户、开发人员、甚至DBA误操作删除了表，那么我们不必还原整个数据库或表空间，直接使用ORACLE10g的闪回(FLASHBACK,闪回)功能来还原被删除的表。这样我们就能避免大量的人工误操作。这是一个对DBA相当有用的功能。 回收站这个特性主要的好处就是在误删除一个表时有一个恢复机制，不必通过数据库还原来实现。避免大量的人工误操作。以及数据库还原等复杂的操作。让数据库的管理、维护更加简单、方便。 管理回收站开启、关闭回收站首先你可以通过命令查看数据库是否开启了回收站机制， 如下所示 VALUE= ON表示开启了回收站机制。OFF则表示回收站机制关闭。 SHOW PARAMETER RECYCLEBIN; SQL> SHOW PARAMETER RECYCLEBIN; NAME TYPE VALUE -------- ----------- ---------- recyclebin string ON 或 SQL> SELECT NAME, VALUE FROM V$PARAMETER WHERE NAME='recyclebin'; NAME VALUE ----------------- -------------------- recyclebin on 可以通过设置初始化参数recyclebin启用或禁用回收站功能。当然也可以用命令关闭回收站 SQL> ALTER SYSTEM SET RECYCLEBIN=OFF; System altered. SQL> ALTER SESSION SET RECYCLEBIN=OFF; Session altered. SQL> SHOW PARAMETER RECYCLEBIN; NAME TYPE VALUE ------------------------------------ ----------- ------------------------------ recyclebin string OFF 可以用命令开启回收站 SQL> ALTER SYSTEM SET RECYCLEBIN=ON; System altered. SQL> ALTER SESSION SET RECYCLEBIN =ON; Session altered. SQL> SHOW PARAMETER RECYCLEBIN; NAME TYPE VALUE ------------------------------------ ----------- ------------------------------ recyclebin string ON oracle10g，在pl/sql中选中删除后会出现类似：BIN$nJ5JuP9cQmqPaArFei384g==$0的表。 1.查看回收站 select * from user_recyclebin; 2.清空回收站 purge recyclebin; 3.清空回收站中的某个表 --如下方式删除会提示：SQL命令未正确结束。 purge table BIN$/UpBuh+LQ9yZGN95BFsk5Q==$0 --正确写法如下： ```sql purge table \"BIN$/UpBuh+LQ9yZGN95BFsk5Q==$0\"; –如下方式删除会提示：SQL命令未正确结束。 drop table BIN$/UpBuh+LQ9yZGN95BFsk5Q==$0 sql --而如下这样写，则会提示：无法对回收站中的对象执行DDL/DML。 drop table \"BIN$0iJ7/rWFQrSGdZexvGv3qQ==$0\" 4.恢复回收站 FLASHBACK TABLE \"BIN$0iJ7/rWFQrSGdZexvGv3qQ==$0\" TO BEFORE DROP 这是10g 的新特性 在10g中，如果启用flash drop功能，在drop表时，数据库不会直接删除，而是将其放在回收站中，当空间出现短缺时，才会逐渐回收这部分空间。 bin$表示表放在了回收站，你想要的话还可以找回来 删除的话一个方法是直接删delete tanle bin$.....; 另一种方法就是使用 purge table table_name; drop table时， 不产生他们，修改你的drop语句 写成 ： DROP TABLE TABLE_NAME PURGE ; 有几种方法可以手动控制回收站 1，。如果在删除名为 TEST 的特定表之后需要从回收站中清除它，可以执行 PURGE TABLE TABLE_NAME; 或者使用其回收站中的名称： PURGE TABLE \"BIN$04LhcpndanfgMAAAAAANPw==$0\"; 2，要从回收站中永久删除索引 PURGE INDEX IN_TEST1_O1 3，清除表空间 USERS 的回收站中的所有对象 PURGE TABLESPACE USERS; 4，只清除特定的用户 PURGE TABLESPACE USERS USER SCOTT; 5，要释放整个回收站占用的空间 PURGE RECYCLEBIN; 重要:PURGE RECYCLEBIN只是清除当前用户回收站中的对象，DBA_RECYCLEBIN下的的对象并没有删除，如果你要清除当前数据库回收站的对象，必须使用下面命令（DBA权限） PURGE DBA_RECYCLEBIN","path":"2018/12/03/oracle-hui-shou-zhan/","date":"12-03","excerpt":""},{"title":"Oracle的11g自动统计信息","text":"一、Oracle 11g在Oracle的11g版本中提供了统计数据自动收集的功能。在部署安装11g Oracle软件过程中，其中有一个步骤便是提示是否启动这个功能(默认是启用这个功能)。在这里介绍一下怎么将该功能启用与禁用： 1、查看自动收集统计信息的任务及状态： select client_name,status from dba_autotask_client; 2、禁止自动收集统计信息的任务 禁用自动收集统计信息的任务可以使用DBMS_AUTO_TASK_ADMIN包完成： SQL> exec DBMS_AUTO_TASK_ADMIN.DISABLE(client_name => 'auto optimizer stats collection',operation => NULL,window_name => NULL); PL/SQL 过程已成功完成。 SQL> select client_name,status from dba_autotask_client; CLIENT_NAME STATUS ---------------------------------------- ---------------- auto optimizer stats collection DISABLED auto space advisor ENABLED sql tuning advisor ENABLED 此时\"auto optimizer stats collection\"任务已经被禁用。 3、启用自动收集统计信息的任务 SQL> exec DBMS_AUTO_TASK_ADMIN.ENABLE(client_name => 'auto optimizer stats collection',operation => NULL,window_name => NULL); PL/SQL 过程已成功完成。 SQL> select client_name,status from dba_autotask_client; CLIENT_NAME STATUS ---------------------------------------- ---------------- auto optimizer stats collection ENABLED auto space advisor ENABLED sql tuning advisor ENABLED 这个功能貌似带来了统计数据采集上的便捷，但是Oracle 11g自动收集统计信息的时间是22:00--2:00 这个时间段往往是业务的高峰期，给本已紧张的系统带来更大的负担。所以，应该把自动执行的时间改到空闲的时段。 4、获得当前自动收集统计信息的执行时间： SQL> select t1.window_name,t1.repeat_interval,t1.duration from dba_scheduler_windows t1,dba_scheduler_wingroup_members t2 2 where t1.window_name=t2.window_name and t2.window_group_name in ('MAINTENANCE_WINDOW_GROUP','BSLN_MAINTAIN_STATS_SCHED'); WINDOW_NAME REPEAT_INTERVAL DURATION ------------------------------ -------------------------------------------------------------------------------- ------------------------------------------------------------------------------- MONDAY_WINDOW freq=daily;byday=MON;byhour=22;byminute=0; bysecond=0 +000 04:00:00 TUESDAY_WINDOW freq=daily;byday=TUE;byhour=22;byminute=0; bysecond=0 +000 04:00:00 WEDNESDAY_WINDOW freq=daily;byday=WED;byhour=22;byminute=0; bysecond=0 +000 04:00:00 THURSDAY_WINDOW freq=daily;byday=THU;byhour=22;byminute=0; bysecond=0 +000 04:00:00 FRIDAY_WINDOW freq=daily;byday=FRI;byhour=22;byminute=0; bysecond=0 +000 04:00:00 SATURDAY_WINDOW freq=daily;byday=SAT;byhour=6;byminute=0; bysecond=0 +000 20:00:00 SUNDAY_WINDOW freq=daily;byday=SUN;byhour=6;byminute=0; bysecond=0 +000 20:00:00 7 rows selected WINDOW_NAME：任务名 REPEAT_INTERVAL：任务重复间隔时间 DURATION：持续时间 修改自动执行的时间 到空闲的时间 1.停止任务： SQL> BEGIN 2 DBMS_SCHEDULER.DISABLE( 3 name => '\"SYS\".\"FRIDAY_WINDOW\"', 4 force => TRUE); 5 END; 6 / PL/SQL 过程已成功完成。 2.修改任务的持续时间，单位是分钟： SQL> BEGIN 2 DBMS_SCHEDULER.SET_ATTRIBUTE( 3 name => '\"SYS\".\"FRIDAY_WINDOW\"', 4 attribute => 'DURATION', 5 value => numtodsinterval(180,'minute')); 6 END; 7 / PL/SQL 过程已成功完成。 3.开始执行时间，BYHOUR=2，表示2点开始执行： SQL> BEGIN 2 DBMS_SCHEDULER.SET_ATTRIBUTE( 3 name => '\"SYS\".\"FRIDAY_WINDOW\"', 4 attribute => 'REPEAT_INTERVAL', 5 value => 'FREQ=WEEKLY;BYDAY=MON;BYHOUR=2;BYMINUTE=0;BYSECOND=0'); 6 END; 7 / PL/SQL 过程已成功完成。 4.开启任务： SQL> BEGIN 2 DBMS_SCHEDULER.ENABLE( 3 name => '\"SYS\".\"FRIDAY_WINDOW\"'); 4 END; 5 / PL/SQL 过程已成功完成。 5.查看修改后的情况： SQL> select t1.window_name,t1.repeat_interval,t1.duration from dba_scheduler_windows t1,dba_scheduler_wingroup_members t2 2 where t1.window_name=t2.window_name and t2.window_group_name in ('MAINTENANCE_WINDOW_GROUP','BSLN_MAINTAIN_STATS_SCHED'); WINDOW_NAME REPEAT_INTERVAL DURATION ------------------------------ -------------------------------------------------------------------------------- ------------------------------------------------------------------------------- WEDNESDAY_WINDOW freq=daily;byday=WED;byhour=22;byminute=0; bysecond=0 +000 04:00:00 FRIDAY_WINDOW FREQ=WEEKLY;BYDAY=MON;BYHOUR=2;BYMINUTE=0;BYSECOND=0 +000 03:00:00 SATURDAY_WINDOW freq=daily;byday=SAT;byhour=6;byminute=0; bysecond=0 +000 20:00:00 THURSDAY_WINDOW freq=daily;byday=THU;byhour=22;byminute=0; bysecond=0 +000 04:00:00 TUESDAY_WINDOW freq=daily;byday=TUE;byhour=22;byminute=0; bysecond=0 +000 04:00:00 SUNDAY_WINDOW freq=daily;byday=SUN;byhour=6;byminute=0; bysecond=0 +000 20:00:00 MONDAY_WINDOW freq=daily;byday=MON;byhour=22;byminute=0; bysecond=0 +000 04:00:00 7 rows selected --查看历史收集情况 SELECT * FROM dba_autotask_client_history WHERE client_name LIKE '%stats%'; 三、手工执行统计信息的自动收集 create table scott.tb_objs as select * from dba_objects; select TABLE_NAME,NUM_ROWS,BLOCKS,LAST_ANALYZED from dba_tables where TABLE_NAME='TB_OBJS'; --执行下面的这个存储过程 SQL> EXEC DBMS_AUTO_TASK_IMMEDIATE.GATHER_OPTIMIZER_STATS; --如下查询，scott表上的统计信息已更新 SQL> select TABLE_NAME,NUM_ROWS,BLOCKS,LAST_ANALYZED from dba_tables where TABLE_NAME='TB_OBJS'; ​ eg: begin dbms_stats.gather_table_stats(ownname => 'CRM', tabname => 'E_TEL_VIPCUST_ADD', estimate_percent => 0.01, degree => 1, cascade => true); end; / FOR循环 示例: DECLARE cursor c_1 is select ename,sal from emp; --定义游标 BEGIN dbms_output.put_line('行号 姓名 薪水'); FOR i IN c_1 --for循环中的循环变量i为c_1%rowtype类型; LOOP dbms_output.put_line(c_1%rowcount||' '||i.ename||' '||i.sal); --输出结果,需要 set serverout on 才能显示. END LOOP; END; declare sqls varchar2(100); BEGIN dbms_output.put_line('******** 表名 ******************'); FOR i IN ( SELECT TABLE_NAME FROM user_tables) --for循环中的循环变量i为c_1%rowtype类型; LOOP sqls := 'create or replace view view_' || i.table_NAME || 'as select * from' || i.table_NAME; begin execute immediate sqls; exception when OTHERS Then dbms_output.put_line(sqlerrm); end; END LOOP; END; 1 ORU-10027:buffer overflow limit of 2000 bytes； 方法1：set serveroutput on size 10000000 //设置大点,默认为2000 bytes 方法2：exec dbms_output.enable(999999999999999999999); //默认为2000 bytes 总结：自动收集的时间周一 ··· 到 周五默认是晚上10点 到 凌晨2两 持续 4个小时周六周日默认是 6点 到 凌晨2点 持续 20个小时","path":"2018/12/03/oracle-de-11g-zi-dong-tong-ji-xin-xi/","date":"12-03","excerpt":""},{"title":"知识时代我们的焦虑 ","text":"在学习中，有一个比掌握知识更重要的能力 来源: i黑马 发布时间: 2018-09-08 16:28 阅读: 26467 次 推荐: 112 原文链接 [收藏] 我究竟该学什么？ 我一朋友的公司，专门给创业者提供创业培训。有一天，他和我聊道， 现在创业者有一个普遍困扰，那就是不知道该学什么好。 我说：为什么？ 他说：你想啊，创业者累成狗，本来时间就很少，结果创业方法今天出一个还没弄明白，明天就又出来一个——根本学不过来啊！ 我一听，嘿嘿乐了。我说，你以为只有创业者累成狗，没时间学那么多东西啊， 我们都一样！ 你看看，今天，不仅新知识产生的速度越来越快，而且知识发布的形式和渠道也越来越多，什么音频说书，视频讲课，在线培训等都在快速增加。这一点， 看“知识付费”行业这两年的快速兴起就是一个例证。 据《2018年中国知识付费市场研究报告》显示，2017年中国知识付费产业规模约49亿元，同比增长近3倍，预计2020年将达到235亿元。 你看，这个行业消费规模的快速攀升背后，就说明有越来越多人渴望更快更多地获取知识，哪怕让他多花一些钱也可以。 员工在想，现在的新知识层出不穷，我不学会落后啊，我学点啥啊？ 老板在想，现在的新打法频繁迭出，我们公司可能什么都没做错，莫名奇妙就被降维攻击了，得学点啥啊？！ 家长在想，这么多育儿方法我一个都不会，让孩子输在起跑线怎办？我学点啥啊？！！ …… 所有这些问题都可以归结于一个问题： 知识太多，学不过来，反而不知道该学点啥了，怎么办啊？ 嗯······要不，就······焦虑吧？ 学习的第一推动力 有那么多知识需要学，可自己却无从下手，焦虑一下也是应该。 况且，现在流行一个说法：人，生而懒惰，学习，天然辛苦。因此： 学习，是一件反人性的事。 哈哈，你看， 如果我们老想着要做一件反人性的事情，不焦虑才怪呢。 不过，要这么说，那些爱学习的人，岂不是快要没人性了——压力山大啊…… 扯远了，让我们回到主题里，我们刚才提到： （1）我们觉得自己要学的知识太多，不知到底应该从何入手？ （2）而学知识又是一个很辛苦的事情，要凭借毅力才能坚持，所以这是逆人性的过程。 因此，我们应该努力克服自己的懒惰，凭借坚强的毅力，努力学习各种知识，吃得苦中苦，方为人上人！对不对？ 我觉得这个结论，貌似正确，实际并不完全。。。甚至可能会让人误入歧途。 为什么这么说？ 因为，学习根本不是一个逆人性、需要坚强毅力的过程。恰恰相反， 学习是最容易产生愉悦心流的事情，学习就是人之天性。 甚至学习不仅是人的天性，也是人类近亲猴子的天性。有研究发现，猴子在没有任何外部奖惩的机制下，自己就会投入精力研究如何打开笼子里的一把锁。 而作为人类，正是由于有探索奥秘、发现新知识的天性，才在一代又一代人的努力下，积累创造了今天的丰富知识。 事实上，世界上本没有知识，人探索的多了，才产生了知识。 可是，为什么我们现在一提到学习，就觉得是一个很辛苦、逆人性的事情呢？ 我想，很大程度上是因为，我们总觉得学习最重要的能力是掌握知识，因此要头悬梁，锥刺股。 然而对于真正会学习的人而言，其实他们并不是简单地靠着毅力来学知识——相反他们有一个隐形的关键能力，这个能力往往把“会学习的人”和“想学习的人”区分了出来。 这就是： 提出问题的能力。 记住： 真正要学习往往不是如何记住知识， 而是如何提出问题。 学习真正的动力不是来自记住知识，而是发现未知，探索好奇，研究问题，克服困难。 我们在解答疑惑的过程中，会聚精会神，会充满斗志，会沉浸其中。我们在记忆概念答案的时候，却抓耳挠腮。 你一定有这样的经验，当你专注于研究探索你好奇事情时，你真的会沉溺于学习无法自拔，感觉不到时间的流逝。而让你死记硬背的时候，你一定更多地是充满绝望。 所以，如果我们只能提升一个学习能力的话，那就聚焦在如何提出感兴趣的问题。 因为， 提出你感兴趣的问题，将是你开展学习的第一推动力 ，剩下的学习过程，都可以因此自然发生。 所以，当我们遇到很多知识，不知道该学哪个的时候，我的答案总是： 如果你不知道你该学什么，就去学你最好奇的。 提问能力是一系列的能力集合 知道、记住“学习的起点是问题”很简单，可是，要真正能够做到这一点，却并不容易。 因为，要做到这一点，需要改变的并不仅仅是理念，而是整个学习流程体系——从学习方法、辅助工具到习惯培养的一系列内容。 比如，说是学习的起点是问题。可是，你一具体操作起来，就会发现： 我过去没有提问这个习惯，不知道该问什么问题啊？ 或者我每天工作很忙，没时间想问题啊？ 又或者，如果我想出很多问题，可是还是回答不了啊…… 类似的一系列问题，都是我们要去面对和解决的。然而，很少有一本书或文章，帮我们回答这些问题。 我自己在践行中发现， 任何一个习惯和能力的培养，真正的阻碍往往在执行的细节里 ，正是这些具体的操作障碍，影响了很多人学习能力的提高。 因此，接下来我稍微多说几句细节的方法，希望对你实际训练能力时会有帮助。 书归正传，在实践中，我把培养提问的习惯，分成两个环节： （1）提出问题； （2）处理问题。 我们这篇文章，主要讨论提问能力，就让我们聚焦在第一个问题吧。 说到提问题能力，我发现有个有趣的现象，那就是人们一旦开始训练自己提问能力的时候，就发现自己——提不出问题。尤其是当你提问提过3天之后，似乎所有问题都被我们问完了，剩下的事情似乎都没毛病啊~Everything is ok（一切都没问题），你让我提什么？ 有一次，我们团队开月度反思会，轮到一个刚入职的新同事发言时，他说：我找不到要反思的内容，感觉就是正常工作，没觉得有什么问题。 当时我就一巴掌抽到自己脸上——好在是在我脑海里抽的…… 我怎么忘了提醒， 提问不是遇到问题才进行的——相反，极端点讲，你得有种“鸡蛋里挑骨头”的精神。 我们觉得自己没问题，就等于我们真的没问题吗？ 当然不是。 不是没有问题，是我们没有发现问题的能力。 我当时问这个同事：你今天的工作，如果换一个你认识的最优秀的人来做，他会和你的做法一样吗？ 同事立刻明白了，对自己“正常”的一天，可能对别人就是“不正常”的一天，只是自己没有发现而已。 我举这个例子只是想说明： 提问这件事情，没我们想的那么简单，是需要用心挖掘的。 既然提问的内容很重要，那我们怎样才能找到比较好的提问角度呢？ 我有一个小技巧可以和你分享： 当你感到自己“动了感情”的时候，就可以动手动脚动脑提问了。 这里说的动感情，不是说你上大街看到美女或帅哥，就上去动手动脚，向人家提问：请问，这块砖头是你掉的吗？ 虽然那也是动感情，也是提问。。。但是，那个跑题了！ 我们这里指的动感情是—— 看电影的时候，可以问：为什么这个桥段会让我感动？发生了什么？ 看到喜欢的电子产品时会问：为什么这个产品让我这么喜欢，是什么让它与众不同？ 看小说入迷到忘却时间会问：为什么我不由自主地沉溺到这段剧情了？ 点完付款按钮之后，会问：我为什么又剁手了，怎么会这样？我是谁？我在哪里？要到哪里去…… 哈哈~ 事实上，所有让你“感兴趣”、想要弄明白的事情，你都可以提出问题：为什么这首歌这么好听？为什么金融业的人收入那么高？为什么老板最近看我的眼神不对了…… 发现自己“感兴趣”的事情，就提醒自己，要有意识地追问原因。 因此，每当我意识到自己被一件事物击中了某种感情的时候，我就会拿出手机，记录下我的感受和问题。 这些积累的问题，都是激发我学习新领域的星光火把——往往我会因为对一个问题的好奇探索，最后进入一个全新的领域学习。 最典型的例子就是，我因为想了解如何能让员工学习能力提升，结果后来反而在学习和知识管理领域做了大量的研究，结果你才能看到《好好学习》和今天的文章，哈哈~ 当然，除了随时随地对感兴趣、好奇的事情提问之外，我还会在每日晨修之时列一个问题： “昨天发生的事情里，我可以提出什么问题呢？” 我把记录晨修日记的过程，当作训练提出问题和回答问题的思考训练，这也是一种非常有效的方式。不过，这个方法只是辅助，目的是有一个固定时间提问的仪式感，提醒自己更好地坚持下次。 好了，总结一下今天的内容： 1、一个重要的学习理念：学习的起点是问题，而不是知识。 2、提出感兴趣的问题，看似简单，可是能持续做到并不容易，是一系列能力的综合体现。 3、有一个技巧可以帮助训练提问能力：在自己动感情的时候，赶紧动手动脚，追问问题。 当然，无论我们文章中介绍了什么方法，都需要践行。正所谓，为者常成，行者常至。","path":"2018/12/03/zhi-shi-shi-dai-wo-men-de-jiao-lu/","date":"12-03","excerpt":""},{"title":"Oracle SQL语句之常见优化方法总结","text":"（以下 方法不能盲信 要以实际情况为准 只是提供一份蓝本） 下面列举一些工作中常常会碰到的Oracle的SQL语句优化方法： 1、SQL语句尽量用大写的； 因为oracle总是先解析SQL语句，把小写的字母转换成大写的再执行。 2、使用表的别名： 当在SQL语句中连接多个表时, 尽量使用表的别名并把别名前缀于每个列上。这样一来, 就可以减少解析的时间并减少那些由列歧义引起的语法错误。 3、选择最有效率的表名顺序(只在基于规则的优化器(RBO)中有效)： ORACLE 的解析器按照从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表 (基础表也称为驱动表,driving table)将被最先处理，在FROM子句中包含多个表的情况下, 必须选择记录条数最少的表作为基础表。如果有3个以上的表连接查询, 那就需要选择交叉 表(intersection table)作为基础表, 交叉表是指那个被其他表所引用的表。 4、WHERE子句中的连接顺序： ORACLE采用自下而上的顺序解析WHERE子句,根据这个原理,表之间的连接必须写在其他 WHERE条件之前, 那些可以过滤掉最大数量记录的条件必须写在WHERE子句的末尾。 5、SELECT子句中避免使用 * ： ORACLE在解析的过程中, 会将’*’ 依次转换成所有的列名, 这个工作是通过查询数据字 典完成的, 这意味着将耗费更多的时间。 6、减少访问数据库的次数： ORACLE在内部执行了许多工作: 解析SQL语句,估算索引的利用率,绑定变量,读数据块等。 7、整合简单、无关联的数据库访问： 如果有几个简单的数据库查询语句,可以整合到一个查询中(即使它们之间没有关系)。 8、在SQLPlus,SQLForms和Pro*C中重新设置ARRAYSIZE参数,可以增加每次数据库访问 的检索数据量,建议值为200。 9、删除重复记录： 最高效的删除重复记录方法 ： DELETE FROM TEMP E WHERE E.ROWID > (SELECT MIN(X.ROWID) FROM TEMP1 X WHERE X.TEMP_NO = E.TEMP_NO); 删除重复的记录只保留一条 DELETE from 表 WHERE (id) IN ( SELECT id FROM 表 GROUP BY id HAVING COUNT(id) > 1) AND ROWID NOT IN (SELECT MIN(ROWID) FROM 表 GROUP BY id HAVING COUNT(*) > 1) 10、减少对表的查询： 在含有子查询的SQL语句中,要特别注意减少对表的查询。 SELECT TAB_NAME FROM TABLES WHERE (TAB_NAME,DB_VER) = ( SELECT TAB_NAME,DB_VER FROM TAB_COLUMNS WHERE VERSION = 604); 11、避免使用耗费资源的操作: 带有DISTINCT、UNION、MINUS、INTERSECT、ORDER BY的SQL语句会启动SQL引擎执行 耗费资源的排序(SORT)功能。DISTINCT需要一次排序操作,而其他的至少需要执行两次排序。 通常,带有UNION、MINUS、INTERSECT的SQL语句都可以用其他方式重写。 如果数据库的SORT_AREA_SIZE调配得好,使用UNION,MINUS,INTERSECT也是可以考虑。 12、优化GROUP BY: 提高GROUP BY 语句的效率,可以通过将不需要的记录在GROUP BY之前过滤掉。 下面两个查询返回相同结果但明显第二个效率更高。 低效: SELECT JOB,AVG(AGE) FROM TEMP GROUP BY JOB HAVING JOB = 'STUDENT' OR JOB = 'MANAGER'; 高效: SELECT JOB,AVG(AGE) FROM EMP WHERE JOB = 'STUDENT' OR JOB = 'MANAGER' GROUP BY JOB; 13、根据需要用UNION ALL替换UNION： 当SQL语句需要UNION两个查询结果集合时,这两个结果集合会以UNION-ALL的方式被合并, 然后在输出最终结果前进行排序。如果用UNION ALL替代UNION, 这样排序就不是必要了。 效率就会因此得到提高。需要注意UNION ALL将重复输出两个结果集合中相同记录。因此要 从业务需求使用UNION ALL的可行性。UNION 将对结果集合排序,这个操作会使用到 SORT_AREA_SIZE这块内存。对于这块内存的优化也很重要。 低效： SELECT USER_ID,BILL_ID FROM USER_TAB1 WHERE AGE = '20' UNION SELECT USER_ID,BILL_ID FROM USER_TAB2 WHERE AGE = '20'; 高效: SELECT USER_ID,BILL_ID FROM USER_TAB1 WHERE AGE = '20' UNION ALL SELECT USER_ID,BILL_ID FROM USER_TAB2 WHERE AGE = '20'; 14、用EXISTS替换DISTINCT： 当SQL包含一对多表查询时,避免在SELECT子句中使用DISTINCT,一般用EXIST替换,EXISTS 查询更为迅速,因为RDBMS核心模块将在子查询的条件一旦满足后,立刻返回结果。 (低效): SELECT DISTINCT USER_ID,BILL_ID FROM USER_TAB1 D,USER_TAB2 E WHERE D.USER_ID= E.USER_ID; (高效): SELECT USER_ID,BILL_ID FROM USER_TAB1 D WHERE EXISTS(SELECT 1 FROM USER_TAB2 E WHERE E.USER_ID= D.USER_ID); 15、尽量多使用COMMIT： 只要有可能,在程序中尽量多使用COMMIT,这样程序的性能得到提高,需求也会因为COMMIT 所释放的资源而减少。 COMMIT所释放的资源: a. 回滚段上用于恢复数据的信息。 b. 被程序语句获得的锁。 c. redo log buffer 中的空间。 d. ORACLE为管理上述3种资源中的内部花销。 16、用Where子句替换HAVING子句： 避免使用HAVING子句,HAVING只会在检索出所有记录之后才对结果集进行过滤。这个处理需 要排序,总计等操作。最好能通过WHERE子句限制记录的数目。 (非oracle中)on、where、having这三个都可以加条件的子句中,on是最先执行,where次之, having最后。 a、on是先把不符合条件的记录过滤后才进行统计，可以减少中间运算要处理的数据，速度是 最快的； b、where比having快点，因为它过滤数据后才进行sum，在两个表联接时才用on的，所以在一 个表的时候，就剩下where跟having比较了。在单表查询统计的情况下，如果要过滤的条件没 有涉及到要计算字段，那它们的结果是一样的，只是where可以使用rushmore技术，而having 就不能，在速度上后者要慢。 如果要涉及到计算的字段，就表示在没计算之前，这个字段的值是不确定的，where的作用 时间是在计算之前就完成的，而having就是在计算后才起作用的，所以在这种情况下，两者 的结果会不同。在多表联接查询时，on比where更早起作用。系统首先根据各个表之间的关联 条件，把多个表合成一个临时表后，再由where进行过滤，然后再计算，计算完后再由having 进行过滤。 17、用TRUNCATE替代DELETE： 当删除表中的记录时,在通常情况下, 回滚段(rollback segments)用来存放可以被恢复的 信息。如果你没有COMMIT事务,ORACLE会将数据恢复到删除之前的状态(准确地说是恢复到执 行删除命令之前的状况)。而当运用TRUNCATE时,回滚段不再存放任何可被恢复的信息。当命 令运行后,数据不能被恢复。因此很少的资源被调用,执行时间也会很短。 注:TRUNCATE只在删除全表适用,TRUNCATE是DDL不是DML。 18、使用DECODE函数来减少处理时间： 使用DECODE函数可以避免重复扫描相同记录或重复连接相同的表。 19、用EXISTS替代IN、用NOT EXISTS替代 NOT IN： 在基于基础表的查询中经常需要对另一个表进行联接。在这种情况下, 使用EXISTS(或NOT EXISTS)通常将提高查询的效率。在子查询中,NOT IN子句将执行一个内部的排序和合并。无 论在哪种情况下,NOT IN都是最低效的(要对子查询中的表执行了一个全表遍历)。所以尽量将 NOT IN改写成外连接(Outer Joins)或NOT EXISTS。 （高效） SELECT A.* FROM TEMP(基础表) A WHERE AGE &gt; 0 AND EXISTS(SELECT 1 FROM TEMP1 WHERE A.ID= ID AND NAME=&#39;TOM&#39;); (低效) SELECT A.* FROM TEMP(基础表) A WHERE AGE &gt; 0 AND A.ID IN(SELECT ID FROM TEMP1 WHERE NAME =&#39;TOM&#39;); 20、用索引提高效率： 索引是表的一个概念部分,用来提高检索数据的效率，ORACLE使用了复杂的自平衡B-tree结 构。通常通过索引查询数据比全表扫描要快。当ORACLE找出执行查询和Update语句的最佳路径 时, ORACLE优化器将使用索引。同样在联结多个表时使用索引也可以提高效率。 另一个使用索引的好处是,它提供了主键(primary key)的唯一性验证。那些LONG或LONG RAW 数据类型, 你可以索引几乎所有的列。通常在大型表中使用索引特别有效。在扫描小表时,使 用索引同样能提高效率。 使用索引虽能得到查询效率的提高,但也必须注意到它的代价。索引需要空间来存储,也需 要定期维护, 每当有记录在表中增减或索引列被修改时, 索引本身也会被修改。这意味着每 条记录的INSERT、DELETE、UPDATE将为此多付出4、5 次的磁盘I/O。因为索引需要额外的存 储空间和处理,一些不必要的索引反而会使查询反应时间变慢。 定期的重构索引: ALTER INDEX &lt;INDEXNAME> REBUILD &lt;TABLESPACENAME> 21、用&gt;=替代&gt;： 高效: SELECT * FROM TEMP WHERE ID >=4; 低效: SELECT * FROM TEMP WHERE ID >3; 区别:前者DBMS将直接跳到第一个ID等于4的记录而后者将首先定位到ID=3的记录并且向前扫 描到第一个ID大于3的记录。 22、避免在索引列上使用NOT： NOT会产生在和在索引列上使用函数相同的影响。当ORACLE遇到NOT,就会停止使用索引转 而执行全表扫描。 23、避免在索引列上使用计算： WHERE子句中，如果索引列是函数的一部分，优化器将不使用索引而使用全表扫描。 低效： SELECT … FROM TEMP WHERE SAL * 12 > 25000; 高效: SELECT … FROM TEMP WHERE SAL > 25000/12; 24、用UNION替换OR(适用于索引列): 用UNION替换WHERE子句中的OR将会起到较好的效果。对索引列使用OR将造成全表扫 描。注意,以上规则只针对多个索引列有效。如果有column没有被索引, 查询效率可能 会因为你没有选择OR而降低。 高效: SELECT * FROM USER_TAB1 WHERE USER_ID = 10 UNION SELECT * FROM USER_TAB1 WHERE AGE = 20; 低效: SELECT * FROM USER_TAB1 WHERE USER_ID = 10 OR AGE = 20; 25、避免在索引列上使用IS NULL和IS NOT NULL 避免在索引中使用任何可以为空的列，ORACLE将无法使用该索引。 对于单列索引，如果列包含空值，索引中将不存在此记录。 对于复合索引，如果每个列都为空，索引中同样不存在此记录。如果至少有一个列不为 空，则记录存在于索引中。 如果唯一性索引建立在表的A列和B列上, 并且表中存在一条记录的A,B值为(123,null), ORACLE将不接受下一条具有相同A,B值（123,null）的记录(插入)。然而如果所有的索引列 都为空，ORACLE将认为整个键值为空而空不等于空。因此你可以插入10000条具有相同键值 的记录,当然它们都是空! 因为空值不存在于索引列中,所以WHERE子句中对索引列进行空 值比较将使ORACLE停用该索引。 低效: (索引失效) SELECT … FROM DEPARTMENT WHERE DEPT_CODE IS NOT NULL; 高效: (索引有效) SELECT … FROM DEPARTMENT WHERE DEPT_CODE >=0; 26、总是使用索引的第一个列： 如果索引是建立在多个列上,只有在它的第一个列(leading column)被where子句引用时, 优化器才会选择使用该索引。 当引用索引的第二个列时,优化器使用了全表扫描而忽略了索引。 27、用WHERE替代ORDER BY： ORDER BY 子句只在以下两种严格的条件下使用索引： (1)ORDER BY中所有的列必须包含在相同的索引中并保持在索引中的排列顺序。 (2)ORDER BY中所有的列必须定义为非空。 WHERE子句使用的索引和ORDER BY子句中所使用的索引不能并列。例如: USER_ID PK NOT NULL USER_DESC NOT NULL USER_TYPE NULL 低效: (索引不被使用) SELECT USER_ID FROM USER_TAB ORDER BY USER_TYPE; 高效: (使用索引) SELECT USER_ID FROM USER_TAB WHERE USER_TYPE> 0; 28、避免改变索引列的类型: 当比较不同数据类型的数据时, ORACLE自动对列进行简单的类型转换。 假设 USER_ID 是一个数值类型的索引列。 SELECT … FROM USER_TAB WHERE USER_ID = '123'; 实际上,经过ORACLE类型转换, 语句转化为: SELECT … FROM USER_TAB WHERE USER_ID = TO_NUMBER('123'); 幸运的是,类型转换没有发生在索引列上,索引的用途没有被改变。 现在,假设USER_TYPE是一个字符类型的索引列。 SELECT … FROM USER_TAB WHERE USER_TYPE = 123 ; 这个语句被ORACLE转换为: SELECT … FROM USER_TAB WHERE TO_NUMBER(USER_TYPE)=123; 因为内部发生的类型转换, 这个索引将不会被用到! 为了避免ORACLE对你的SQL进行隐式的类 型转换, 最好把类型转换用显式表现出来。 注：当字符和数值比较时, ORACLE会优先转换数值类型到字符类型。 SELECT … FROM USER_TAB WHERE TO_NUMBER(USER_TYPE)=123; 29、WHERE子句: 某些SELECT 语句中的WHERE子句不使用索引。 (1)'!='不走索引。索引只能告诉我们什么存在于表中, 而不能告诉你什么不在表中。 (2)'||'是字符连接函数。就象其他函数那样, 停用了索引。 (3)'+'是数学函数。和其他数学函数一样, 停用了索引。 (4)相同的索引列不能互相比较,这将会启用全表扫描。 30、 a.如果检索数据量超过30%的表中记录数，使用索引将没有显著的效率提高。 b.在特定情况下,使用索引也许会比全表扫描更慢,但这是同一个数量级上的区别。` `而通常情况下,使用索引比全表扫描要块几倍乃至几千倍。` 31、查’低效执行’的SQL语句： SELECT EXECUTIONS,DISK_READS,BUFFER_GETS, ROUND((BUFFER_GETS-DISK_READS)/BUFFER_GETS,2) HIT_RADIO, ROUND(DISK_READS/EXECUTIONS,2) Reads_per_run,SQL_TEXT FROM V$SQLAREA WHERE EXECUTIONS > 0 AND BUFFER_GETS > 0 AND (BUFFER_GETS-DISK_READS)/BUFFER_GETS < 0.8 ORDER BY 4 DESC; -——————–","path":"2018/12/03/oracle-sql-yu-ju-zhi-chang-jian-you-hua-fang-fa-zong-jie/","date":"12-03","excerpt":""},{"title":"linux 常用命令","text":"用户命令 pwd 显示当前目录 cd 后面不加东西就回到家目录（/home/用户），加的话就到某地址，绝对路径则从/开始，.表示当前目录，..到上一级目录，-表示上一个目录（比如原来我从A切换到B目录，用-则从B回到A目录），/表示回到根目录，~表示家目录 tail 查看文件末尾多少行 tail -100f 日志文件名 hostname 查看主机名，后面如果加新名字则修改当前主机名，但只是暂时修改，重开命令行则主机名又变回去了 id 显示当前用户信息 whoami 当前登录用户名，举例： dawson@dawson-PC:/home/dawson/Desktop$ whoami dawson who 查看有哪些登录了的用户及其终端名和注册到系统的时间等，举例： dawson@dawson-PC:/home/dawson/Desktop$ who dawson tty7 2018-05-08 15:56 (:0) w 查看哪些用户登录并且在干什么，举例： dawson@dawson-PC:/home/dawson/Desktop$ w 17:14:27 up 1:18, 1 user, load average: 0.11, 0.13, 0.17 USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT dawson tty7 :0 15:56 1:18m 35.22s 2.12s /usr/bi useradd 用户名 新建用户，-g指定用户所在组名或登录时的初始组标志号，-G指定新用户的附加组，-P指定用户密码，-u指定用户标志号的数值 userdel 用户名 删除用户 groupadd 添加新的用户组，-g指定GID（要大于500），-o表示该组GID可以不唯一，-r添加一个系统账号组（要小于499） groupdel 删除用户组 groupmod 修改组属性 more 文件名 /cat 文件名 | more 用于特别多内容的文件将其一页一页显示，但只能向下翻页，如果想上下翻页都可以用-less，如果只看头几行可以head -n，如果想看末尾几行可以tail -n（默认都是10行），如果想动态看文件更新可以加-f sort 文件名 给文件内容排序输出（不改变源文件内容），默认按每行首字母排序，如果-k加数字范围代表从每行的第某个字符到某个字符之间作为关键字排序，-r代表逆向排序，举例： sort -k 2,3 abc #以每行第三个字段作为关键字排序 uniq 文件 删除内容的重复行后输出（不改变源文件内容），举例： uniq abc diff 文件1 文件2 比较两个文件的不同，文件内容不需要排序 comm 文件1 文件2 比较两个文件，显示他们共有的行，但是要求文件内容排好序先 ln 文件1 文件2 对文件1创建一个硬链接，名字为文件2，只能对文件创建，删除源文件对其没有影响，内容还在，可以继续使用；如果加上-s，就是创建符号链接，实质是保存了要链接文件的绝对路径及文件名，会建立一个新文件，可以对文件/目录进行创建，但是一旦源文件删除，这个也就不能用了，相当于创建一个快捷方式 ls 查看当前目录文件： -a 显示所有文件（包括隐藏文件） -l 显示详细信息 -R 递归显示子结构目录 -ld 文件名 显示该文件目录和链接信息 -t 以文件最后修改时间排序显示 -S 以文件大小递降排序显示 su - 什么都不加将切换入root模式，加用户名切换至某用户，输入exit退出用户 passwd 修改用户密码，如果修改想不用原密码可以前面加sudo history 查看输入命令历史，并且可以通过：！数字，来运行对应命令，举例： dawson@dawson-PC:~/Desktop$ history | tail -3 565 tail -3 history 566 ls 567 history | tail -3 dawson@dawson-PC:~/Desktop$ !566 ls aaa abc cba 网页前端.txt #运行第566条命令ls clear 清屏 alias 别名=”命令” 给命令设置别名，举例： alias ll=&quot;ls -l&quot; 则输入ll和输入ls -l就一样了，要取消别名时就输入unalias别名就行了，比如取消上面的ll，就： unalias ll whereis 命令名 告诉你命令存放的位置，举例： dawson@dawson-PC:~$ whereis ls ls: /bin/ls /usr/share/man/man1/ls.1.gz basename 取你指令中的最后一个文件名，例如： basename /home/dawson/Desktop 则结果就是Desktop（这个目录下/home/dawson是目录，Desktop是文件），然后dirname是取目录名，对前面那个就是/home/dawson type 命令名 显示这个指令信息，加-t参数会显示这个指令是外部指令还是内置指令，加-a会显示PATH下所有有其的路径 网络配置命令 ifconfig 查看网络配置，后面-a则查看所有接口，如果后面输入的是某个接口名则只查看该接口，例如eth0则查看eth0接口，激活接口用up参数，关闭用down，如启用网卡eth0：ifconfig eth0 up，还有设置ip地址和子网掩码以及广播地址等，举例： ifconfig eth0 192.168.2.10 netmask 255.255.255.0 broadcast 192.168.2.255 route 不带参数显示当前路由表内容，可以设置网关，如： route add default gw 192.168.120.240 删除就把add改成del；也可以设置路由，如： route add -net 221.56.76.0 netmask 255.255.255.0 eth0 setup 直接进入网络配置界面 host 网址 测试DNS解析是否正常，如果返回ip地址则正常，dig命令也可以解析，并且返回的内容更详细 ip route 显示路由表 traceroute url 追踪到达目标地址的网络路径 nslookup 检测DNS服务器，输入后会进入一个&gt;提示符的界面，里面可以输入域名或ip地址检测DNS，或者直接： nslookup ip/域名 mtr url 对达到目标地址进行网络测试（结合ping和traceroute），会动态更新路由信息，loss表示丢失率，snt表示发了多少包， 任务进程命令 后面加&amp; 如果直接打开一个文件，将会使当前命令行在占用当中，加了&amp;可以在后台打开某文件，从而继续使用命令行，例如后台打开火狐： firefox &amp; sleep 时间 让某个任务停止多长时间、 bg 数字 让第几个任务继续在后台运行 fg 数字 让第几个任务在前台运行 jobs 查看后台作业情况，例如上面命令把火狐放后台运行，则jobs后会看到火狐 ps 查看当前系统中运行的进程信息 -e 显示所有进程信息 -f 显示详细信息 -数字 显示某一id进程信息 r （没有-）只显示正在运行的进程 u （没有-）以偏用户风格样式显示 kill pid 终止某一个进程，进程可以用ps查看 解压缩命令 zip 压缩后文件名 文件名 压缩某文件并命名，还有用gzip压缩，把zip改成gzip就行了 unzip 压缩文件名 解压某文件 tar -cvf 归档后文件名 文件名 归档某文件（只打包不压缩），-c创建归档，如果想归档的同时也压缩则用-cvzf（gzip压缩），f是指定压缩文件，z是按gzip压缩，v是显示操作过程，如果是按bzip2压缩就是j，如果是按compress压缩是Z tar -xvf 归档文件名 解放某归档文件，如果是.tar.gz文件（即经过gzip压缩的）就要-xvzf，如果是.tar.bz2就要-xvjf 文件管理命令 cp 源文件名 目标文件名 复制某文件，并赋予新文件名，如果源文件名后面加的只是地址，则将源文件复制到某目录下，名字不变 cp -r 源文件夹 目标文件夹 复制文件夹，如果要查看详细信息则-v mv 源文件名 目标文件夹/目标文件名 移动文件到目标文件夹/文件重命名 touch 后面加个文件名，创建一个新文件或者修改指定文件的时间标签 rm 文件名 删除某个文件，如果是文件夹要加个-r在前面，如果删除的内容要自己确认哪个删哪个不删则加-i，如果要强制删除则-f cat 查看某文件内容，但主要是文本文件，假如是二进制文件可能就会都是乱码，所以可以用od来读取二进制（od 文件名） tee 将某文件重定向的同时还输出在屏幕上 mkdir 文件夹名（目录） 创建一个文件夹（目录），如果加-p，则可以循环创建目录，举例： mkdir a/b/c 则依次创建这三个目录，如果想创建时就确定他的权限就可以用-m参数，举例： mkdir -m 777 abc rmdir 文件夹名（目录） 删除一个空文件夹（空目录），要删除非空的就用前面的rm -r file 文件名 查看文件类型 directory：目录文件 -：普通文件，或更准确地说，不属于以上几种类型的文件 l：符号链接(指向另一个文件,类似于瘟下的快捷方式) s：套接字文件 b：块设备文件,二进制文件 c：字符设备文件 p：命名管道文件 locate 关键词 快速搜索带某关键字文件，因为是直接查数据库所以查的快，但有时可能不能实时查到最新的文件，需要updatedb更新数据库，可能会花点时间 find 查找位置 查找参数 参数数据 查找位置如果在当前目录则.，如果根分区则/，查找参数如果按名字则-name，参数数据可以参考通配符（例如查找所有配置文件：*.conf） grep 关键字 目录 基于某个关键字在该目录下搜索文本 -I 忽略大小写 -n 显示结果所在行数 -v 输出不带关键字的行 -Ax 输出包含结果开始之后的内容 -Bx 输出包含结果所在行之前的内容 wc 文件名 统计文本信息 -l 只统计行数 -w 只统计单词 -c 只统计字节数 -m 只统计字符数 sort 文件名 对文本内容进行排序 -r 倒序排序 -n 基于数字排序 -f 忽略大小写 -u 删除重复行 diff 文件名1 文件名2 比较两文件信息 -I 忽略大小写 -b 忽略空格数量的改变 -u 统一显示比较信息 sed ‘s/搜索内容/替换成的内容/g’ 文件名 用于搜索某文件里的内容并对该内容进行替换，g如果不写则只替换第一个，有g则全部替换 vim/vi 文件名 用vim编辑器编辑 i 当前位置开始插入 I 当前行的行首开始插入 o 在当前行回车进入下一行 dd 删除整行 yy 复制当前行 n+yy 复制n行当前行 P 粘贴 u 撤销 r 替换当前字符 / 查找关键字 :w 保存 :q 退出 :q! 直接退出不保存 :wq 保存并退出 :x 只有当内容被修改过后才保存并退出，否则直接退出 :ZZ 和x一样 number 显示行号 :!系统命令 运行系统命令并显示结果 :sh 切换回命令行（要再切换回来则ctrl+d），每次用快捷键需要按下esc退出前个模式 特殊 sz 文件名 将linux文件保存到windows本地，需要安装，然后一般在windows远程终端（如xshell）运行（在linux命令行里运行会卡住） 系统命令 init 数字 1-单用户模式（进来就只能是root模式，密码都不用输，如果要修改root的密码必须得进这里面改） 2-不带网络的多用户模式（进来输入用户名密码登录），只有命令行界面 3-多用户模式，只有命令行界面（常用） 5-图形界面，就是正常开机的（常用） 6-重启 shutdown -h/-r 时间 -h则多久后关机，-r多久后重启（时间可以是now、+10代表10分钟后、23:30代表那时候关）如果想立即关机则poweroff，如果要立即重启则reboot，举例： shutdown -h now #立刻关机 date 查看当前系统时间，可以后面加显示格式，例如： date +%Y/%m/%d cal 看日历时间，想看某月某日则：cal month year，例如： cal 3 2018 bc 计算器，输入后即可输入计算语句（例如：1+1等），默认整数精度，要精确小数则先输入：scale=精确度数（例如：scale=3），输入quit离开 uptime 看系统使用时间 lspci 看PCI设备，-v看详细信息 lsusb 看USB设备，-v看详细信息 lsmod 看加载模块，驱动信息 uname -r 查看系统内核信息，举例： dawson@dawson-PC:~$ uname -r 4.9.0-deepin9-amd64 lsb_release -a 查看LSB(Linux Standard Base)信息，举例： dawson@dawson-PC:~$ lsb_release -a No LSB modules are available. Distributor ID: Deepin Description: Deepin 15.4.1 Release: 15.4.1 Codename: unstable top 性能分析 fdisk 磁盘操作命令，需要root权限 -h/--help 查看该命令下的帮助 man 命令名 列出某一命令的完整说明 info 命令名 列出更详细的命令说明 which 命令名 找到命令存放的位置，whereis也是查找命令存放的位置，但假如一个命令在/bin和/root都有，which只有输出第一个找到的位置，而whereis会把所有找到的位置都输出 chmod 模式 文件名 修改文件权限，模式可以用+、-来加减权限，如给用户加读、写权限则chmod u+rw 文件名，还有一种数字方式，其中权限r=4，w=2，x=1，例如UGO都可读写则为chmod 666 文件名 sync 将数据同步写入磁盘 df 查看磁盘使用量，加-h可以️以较易阅读的KB/GB等格式显示 dump 备份文件系统 restore 恢复备份 RPM软件包管理 rpm -i 文件名（包括版本后缀名rpm） 安装软件（一般会加上详细信息v和显示进度条h，即-ivh） rpm -e 文件名（就前面文件名） 卸载软件 rpm -U 文件名（包括新版本号和后缀名） 更新软件 rpm -K 文件名（包括版本后缀名） 验证该安装包是否被恶意修改，ok则说明没问题 rpm -V 文件名（就前面文件名） 查看该文件安装后是否修改过 rpm -qa 显示所有rpm包安装的文件 rpm -qi 文件名（就前面文件名） 显示该软件详细信息，如果是为安装的软件想要查看其详细信息就加个p，即-qip rpm -ql 文件名（就前面文件名） 列出属于这个软件的文件，未安装的就-qlp yum软件管理 yum install 软件名（就软件名） 安装软件 yum remove 软件名 删除软件 yum update 软件名 更新软件 yum search 关键字 搜索包含该关键字的软件 yum list all/installed/recent/updates 列出所有/安装/最近/更新的软件信息 yum info 软件名 查看该软件详细信息 引用作者：dawsonenjoy 引用链接：https://www.jianshu.com/p/042593bd1bb6","path":"2018/12/03/linux-chang-yong-ming-ling/","date":"12-03","excerpt":""},{"title":"Oracle取月份-不带前面的0","text":"第一： 利用to_number的函数转换自动截0 select to_number(to_char(sysdate,'mm'))||'-'||to_number(to_char(sysdate,'dd')) from dual; 第二： 利用ltrim函数加固定参数去掉0 select ltrim(to_char(sysdate,'mm'),'0')||'-'||ltrim(to_char(sysdate,'dd'),'0') from dual; 上面两种方法实现了我们所需要的，共同的特点是都用到两个函数了，但有没有更简单的方法呢 ？ 我猜有的人肯定就想到了oracle是不是有这样的格式呢 select to_char(sysdate,’m-d’) from dual; 很可惜，提示错误，日期格式不存在 。不要灰心，我们继续… 第三：利用函数的特性。 我们知道 select sysdate from dual ; 得到的值是：2010-1-8 11:06:18 那有没有函数直接获取到月份1和日8， www.2cto.com 我们的猜测是正确的，确实有这样的函数，出现了下面的函数， select extract(month from sysdate) ||'-'|| extract(day from sysdate) month from dual; 注意： extract 具体的用法找’google’吧 ，不会让你失望的。 又近了一步，满足了吧，不要满足了，下面还有。 上面的方法有一个共同的特征，就是月和日都是分开取的，怎么样才能 合并到一起去，这样多好啊 ！ 看我们的第四种方法： 第四：巧用oracle自带的格式 select to_char(sysdate,&#39;fmmm-dd&#39;) from dual; ps：the format_mask parameter begins with “FM”. This means that zeros and blanks are suppressed","path":"2018/12/03/oracle-qu-yue-fen-bu-dai-qian-mian-de-0/","date":"12-03","excerpt":""},{"title":"oracle  ora00600错误代码","text":"方法/步骤 进入CMD ,执行 set oracle_sid=orcl 运行 sqlplus scott/tiger as sysdba 2/2 分步阅读 最简单的解决方式： 1、shutdown immediate; 2、startup mount; 3、alter database open; 2/2 如果第一步没解决，再进行下面的操作 1、shutdown immediate; 2、startup mount; 3、recover database using backup controlfile; 4、指定日志：输入你的最新的日志文件位置。 5、alter database open resetlogs; 6、shutdown immediate; 7、startup; https://jingyan.baidu.com/article/90bc8fc89f3a5ff653640c27.html","path":"2018/12/03/oracle-ora00600-cuo-wu-dai-ma/","date":"12-03","excerpt":""},{"title":"软件测试","text":"1，测试的划分 单元测试： 单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。 集成测试（也叫组装测试，联合测试）是单元测试的逻辑扩展。它最简单的形式是：把两个已经测试过的单元组合成一个组件，测试它们之间的接口。 系统测试是针对整个产品系统进行的测试，目的是验证系统是否满足了需求规格的定义，找出与需求规格不符或与之矛盾的地方，从而提出更加完善的方案。系统测试发现问题之后要经过调试找出错误原因和位置，然后进行改正。 验收测试是部署软件之前的最后一个测试操作。 2，静态测试和动态测试 静态测试:静态方法是指不运行被测程序本身，仅通过分析或检查源程序的语法、结构、过程、接口等来检查程序的正确性。对需求规格说明书、软件设计说明书、源程序做结构分析、流程图分析、符号执行来找错。 动态测试:实际的执行被测对象的程序代码，输入实现设计好的测试用例，检查程序代码运行得到的结果与测试用例中设计的预期结果之间是否有差异，判定实际结果与预测结果是否一致。 动态测试有四部分组成：设计测试用例，执行测试用例，分析比较输出结果，输出测试报告。 按是否运行程序划分 静态测试 静态方法是指不运行被测程序本身，仅通过分析或检查源程序的语法、结构、过程、接口等来检查程序的正确性。对需求规格说明书、软件设计说明书、源程序做结构分析、流程图分析、符号执行来找错。静态测试结果可用于进一步的查错，并为测试用例选取提供指导。 动态测试 实际的执行被测对象的程序代码，输入实现设计好的测试用例，检查程序代码运行得到的结果与测试用例中设计的预期结果之间是否有差异，判定实际结果与预测结果是否一致。 动态测试有四部分组成：设计测试用例，执行测试用例，分析比较输出结果，输出测试报告。 需求说明书、需求规格说明书 按照是否查看源代码分 白盒测试 基于软件内部设计和程序实现的测试方式。 黑盒测试 基于软件需求，而不是基于软件内部设计和程序实现的测试方式。 黑盒测试—功能测试 Functional testing（功能测试），也称为behavioral testing（行为测试），根据产品特性、操作描述和用户方案，测试一个产品的特性和可操作行为以确定它们满足设计需求。 黑盒测试—性能测试 通常验证软件的性能在正常环境和系统条件下重复使用是否还能满足性能指标同时发现系统中存在的性能瓶颈，起到优化系统的目的。 3,白盒测试和黑盒测试? 白盒测试:基于软件内部设计和程序实现的测试方式 黑盒测试:基于需求设计，不根据软件内部设计和程序实现的测试方法。 4，测试的项目周期 v模型 V模型即包含了底层测试又包含了高层测试； 底层测试：检验源代码质量的测试，如：单元测试。 高层测试：检验整个系统的需要，如：系统测试。 V模型清楚地标识出了软件开发的阶段。 它采用自顶向下逐步求精的方式把整个开发过程分成不同的阶段，每个阶段的工作都很明确，因此便于控制开发过程。当所有的阶段都完成之后，该软件的开发过程也随之结束。 V模型仅仅把测试过程作为在需求分析、概要设计、详细设计以及编码之后的一个阶段，容易使人误解测试是软件开发的最后一个阶段，是软件开发的从属。 V模型的另一个大缺点正是它自身的顺序性所导致的。到了测试阶段，程序已经完成，错误已经产生，很多前期的错误一直到测试阶段才发现，甚至无法发现，往往无从修改了。 同时实际的开发过程中，在需求阶段很难把用户的需求完全明确下来，因此，当需求变更时将会导致阶段反复，而且都要重复需求、设计、编码、测试等过程，返工量非常大，模型灵活性比较低。 V模型仅仅把测试过程作为在需求分析、概要设计、详细设计以及编码之后的一个阶段，容易使人误解测试是软件开发的最后一个阶段，是软件开发的从属。 V模型的另一个大缺点正是它自身的顺序性所导致的。到了测试阶段，程序已经完成，错误已经产生，很多前期的错误一直到测试阶段才发现，甚至无法发现，往往无从修改了。 同时实际的开发过程中，在需求阶段很难把用户的需求完全明确下来，因此，当需求变更时将会导致阶段反复，而且都要重复需求、设计、编码、测试等过程，返工量非常大，模型灵活性比较低。 等价类 划分等价的原则 定义：将输入的数据划分成若干类，从每类选取数据。选取的测试数据的测试结果代表这个类别。 分类： 有效等价类：对于程序来说，是合理的、有意义的数据。 无效等价类：对于程序来说，是不合理的、没有意义的数据。 划分等价类的原则 如果输入条件规定了取值范围或者取值个数，则可以确定一个有效等价类和 两个无效等价类。 如果输入条件规定了输入的集合，或规定了“必须如何”的条件，则可以确 定一个有效等价类和一个无效等价类。 如果输入条件是一个布尔值，可以确定一个有效等价类和一个无效等价类。 如果规定了输入一组n个数据，且程序对每个输入值分别进行处理，则为每一 个输入值确定一个有效等价类，共n个有效等价类，在这组值以外确定一个无效等价类。 如果规定了输入的数据必须遵守的n条规则，则可以确定满足所有需求的一个 有效等价类，和违反每条规则的n条无效等价类。 设计一个新的测试用例，使其尽量多的覆盖已经列出的尚未被覆盖的有效等价类，直到所有的有效等价类都被覆盖为止。 设计一个新的测试用例，使其仅覆盖一个已经列出的尚未被覆盖的无效等价类，重复这一步，直到所有列出的无效等价类都被覆盖为止。 边界值-基础概念 场景法 判定表 因果图 选择题 用逻辑判断来 测试单元的需求分析 描绘单元，分解单元， 单元细化 分析需求测试的原则 完整的 ，正确性 ，一致性 可行性 软件测试中的风险以及风险管理","path":"2018/12/03/ruan-jian-ce-shi/","date":"12-03","excerpt":""},{"title":"Spark-Hadoop、Hive、Spark 之间是什么关系？","text":"大数据本身是个很宽泛的概念，Hadoop生态圈（或者泛生态圈）基本上都是为了处理超过单机尺度的数据处理而诞生的。你可以把它比作一个厨房所以需要的各种工具。锅碗瓢盆，各有各的用处，互相之间又有重合。你可以用汤锅直接当碗吃饭喝汤，你可以用小刀或者刨子去皮。但是每个工具有自己的特性，虽然奇怪的组合也能工作，但是未必是最佳选择。 大数据，首先你要能存的下大数据。 传统的文件系统是单机的，不能横跨不同的机器。HDFS（Hadoop Distributed FileSystem）的设计本质上是为了大量的数据能横跨成百上千台机器，但是你看到的是一个文件系统而不是很多文件系统。比如你说我要获取/hdfs/tmp/file1的数据，你引用的是一个文件路径，但是实际的数据存放在很多不同的机器上。你作为用户，不需要知道这些，就好比在单机上你不关心文件分散在什么磁道什么扇区一样。HDFS为你管理这些数据。 存的下数据之后，你就开始考虑怎么处理数据。虽然HDFS可以为你整体管理不同机器上的数据，但是这些数据太大了。一台机器读取成T上P的数据（很大的数据哦，比如整个东京热有史以来所有高清电影的大小甚至更大），一台机器慢慢跑也许需要好几天甚至好几周。对于很多公司来说，单机处理是不可忍受的，比如微博要更新24小时热博，它必须在24小时之内跑完这些处理。那么我如果要用很多台机器处理，我就面临了如何分配工作，如果一台机器挂了如何重新启动相应的任务，机器之间如何互相通信交换数据以完成复杂的计算等等。这就是MapReduce / Tez / Spark的功能。MapReduce是第一代计算引擎，Tez和Spark是第二代。MapReduce的设计，采用了很简化的计算模型，只有Map和Reduce两个计算过程（中间用Shuffle串联），用这个模型，已经可以处理大数据领域很大一部分问题了。 那什么是Map什么是Reduce？ 考虑如果你要统计一个巨大的文本文件存储在类似HDFS上，你想要知道这个文本里各个词的出现频率。你启动了一个MapReduce程序。Map阶段，几百台机器同时读取这个文件的各个部分，分别把各自读到的部分分别统计出词频，产生类似 （hello, 12100次），（world，15214次）等等这样的Pair（我这里把Map和Combine放在一起说以便简化）；这几百台机器各自都产生了如上的集合，然后又有几百台机器启动Reduce处理。Reducer机器A将从Mapper机器收到所有以A开头的统计结果，机器B将收到B开头的词汇统计结果（当然实际上不会真的以字母开头做依据，而是用函数产生Hash值以避免数据串化。因为类似X开头的词肯定比其他要少得多，而你不希望数据处理各个机器的工作量相差悬殊）。然后这些Reducer将再次汇总，（hello，12100）＋（hello，12311）＋（hello，345881）= （hello，370292）。每个Reducer都如上处理，你就得到了整个文件的词频结果。 这看似是个很简单的模型，但很多算法都可以用这个模型描述了。 Map＋Reduce的简单模型很黄很暴力，虽然好用，但是很笨重。第二代的Tez和Spark除了内存Cache之类的新feature，本质上来说，是让Map/Reduce模型更通用，让Map和Reduce之间的界限更模糊，数据交换更灵活，更少的磁盘读写，以便更方便地描述复杂算法，取得更高的吞吐量。 有了MapReduce，Tez和Spark之后，程序员发现，MapReduce的程序写起来真麻烦。他们希望简化这个过程。这就好比你有了汇编语言，虽然你几乎什么都能干了，但是你还是觉得繁琐。你希望有个更高层更抽象的语言层来描述算法和数据处理流程。于是就有了Pig和Hive。Pig是接近脚本方式去描述MapReduce，Hive则用的是SQL。它们把脚本和SQL语言翻译成MapReduce程序，丢给计算引擎去计算，而你就从繁琐的MapReduce程序中解脱出来，用更简单更直观的语言去写程序了。 有了Hive之后，人们发现SQL对比Java有巨大的优势。一个是它太容易写了。刚才词频的东西，用SQL描述就只有一两行，MapReduce写起来大约要几十上百行。而更重要的是，非计算机背景的用户终于感受到了爱：我也会写SQL！于是数据分析人员终于从乞求工程师帮忙的窘境解脱出来，工程师也从写奇怪的一次性的处理程序中解脱出来。大家都开心了。Hive逐渐成长成了大数据仓库的核心组件。甚至很多公司的流水线作业集完全是用SQL描述，因为易写易改，一看就懂，容易维护。 自从数据分析人员开始用Hive分析数据之后，它们发现，Hive在MapReduce上跑，真鸡巴慢！流水线作业集也许没啥关系，比如24小时更新的推荐，反正24小时内跑完就算了。但是数据分析，人们总是希望能跑更快一些。比如我希望看过去一个小时内多少人在充气娃娃页面驻足，分别停留了多久，对于一个巨型网站海量数据下，这个处理过程也许要花几十分钟甚至很多小时。而这个分析也许只是你万里长征的第一步，你还要看多少人浏览了跳蛋多少人看了拉赫曼尼诺夫的CD，以便跟老板汇报，我们的用户是猥琐男闷骚女更多还是文艺青年／少女更多。你无法忍受等待的折磨，只能跟帅帅的工程师蝈蝈说，快，快，再快一点！ 于是Impala，Presto，Drill诞生了（当然还有无数非著名的交互SQL引擎，就不一一列举了）。三个系统的核心理念是，MapReduce引擎太慢，因为它太通用，太强壮，太保守，我们SQL需要更轻量，更激进地获取资源，更专门地对SQL做优化，而且不需要那么多容错性保证（因为系统出错了大不了重新启动任务，如果整个处理时间更短的话，比如几分钟之内）。这些系统让用户更快速地处理SQL任务，牺牲了通用性稳定性等特性。如果说MapReduce是大砍刀，砍啥都不怕，那上面三个就是剔骨刀，灵巧锋利，但是不能搞太大太硬的东西。 这些系统，说实话，一直没有达到人们期望的流行度。因为这时候又两个异类被造出来了。他们是Hive on Tez / Spark和SparkSQL。它们的设计理念是，MapReduce慢，但是如果我用新一代通用计算引擎Tez或者Spark来跑SQL，那我就能跑的更快。而且用户不需要维护两套系统。这就好比如果你厨房小，人又懒，对吃的精细程度要求有限，那你可以买个电饭煲，能蒸能煲能烧，省了好多厨具。 上面的介绍，基本就是一个数据仓库的构架了。底层HDFS，上面跑MapReduce／Tez／Spark，在上面跑Hive，Pig。或者HDFS上直接跑Impala，Drill，Presto。这解决了中低速数据处理的要求。 那如果我要更高速的处理呢？ 如果我是一个类似微博的公司，我希望显示不是24小时热博，我想看一个不断变化的热播榜，更新延迟在一分钟之内，上面的手段都将无法胜任。于是又一种计算模型被开发出来，这就是Streaming（流）计算。Storm是最流行的流计算平台。流计算的思路是，如果要达到更实时的更新，我何不在数据流进来的时候就处理了？比如还是词频统计的例子，我的数据流是一个一个的词，我就让他们一边流过我就一边开始统计了。流计算很牛逼，基本无延迟，但是它的短处是，不灵活，你想要统计的东西必须预先知道，毕竟数据流过就没了，你没算的东西就无法补算了。因此它是个很好的东西，但是无法替代上面数据仓库和批处理系统。 还有一个有些独立的模块是KV Store，比如Cassandra，HBase，MongoDB以及很多很多很多很多其他的（多到无法想象）。所以KV Store就是说，我有一堆键值，我能很快速滴获取与这个Key绑定的数据。比如我用身份证号，能取到你的身份数据。这个动作用MapReduce也能完成，但是很可能要扫描整个数据集。而KV Store专用来处理这个操作，所有存和取都专门为此优化了。从几个P的数据中查找一个身份证号，也许只要零点几秒。这让大数据公司的一些专门操作被大大优化了。比如我网页上有个根据订单号查找订单内容的页面，而整个网站的订单数量无法单机数据库存储，我就会考虑用KV Store来存。KV Store的理念是，基本无法处理复杂的计算，大多没法JOIN，也许没法聚合，没有强一致性保证（不同数据分布在不同机器上，你每次读取也许会读到不同的结果，也无法处理类似银行转账那样的强一致性要求的操作）。但是丫就是快。极快。 每个不同的KV Store设计都有不同取舍，有些更快，有些容量更高，有些可以支持更复杂的操作。必有一款适合你。 除此之外，还有一些更特制的系统／组件，比如Mahout是分布式机器学习库，Protobuf是数据交换的编码和库，ZooKeeper是高一致性的分布存取协同系统，等等。 有了这么多乱七八糟的工具，都在同一个集群上运转，大家需要互相尊重有序工作。所以另外一个重要组件是，调度系统。现在最流行的是Yarn。你可以把他看作中央管理，好比你妈在厨房监工，哎，你妹妹切菜切完了，你可以把刀拿去杀鸡了。只要大家都服从你妈分配，那大家都能愉快滴烧菜。 你可以认为，大数据生态圈就是一个厨房工具生态圈。为了做不同的菜，中国菜，日本菜，法国菜，你需要各种不同的工具。而且客人的需求正在复杂化，你的厨具不断被发明，也没有一个万用的厨具可以处理所有情况，因此它会变的越来越复杂。 作者：Xiaoyu Ma 链接：https://www.zhihu.com/question/27974418/answer/38965760 来源：知乎","path":"2018/12/03/spark-hadoop-hive-spark-zhi-jian-shi-shi-me-guan-xi/","date":"12-03","excerpt":""},{"title":"ORACLE 加强学习","text":"本次知识点1,掌握 oracle中把一张表中的数据复制到另一张表中去 2,oraclhe中创建索引 3, oracle中临时表的创建 4,oracle中创建视图 5,oracle中删除drop truncate delete 的区别 6,oracle中创建储存过程 7,oracle中创建游标 8,oracle中创建触发器 9,oracle 中的 恢复 表数据 10,oracle 中的导入导出操作 1，复制表001，如果没有表结构创建表结构 CREATE TABLE 新表 AS SELECT * FROM 旧表 WHERE 1=2; 002，向新表中复制数据 insert into 新表 select * from 旧表; 003，同一个表中 将表中的a字段的值 赋给 b字段 update 表名set A=B; 2，索引CREATE [UNIQUE] INDEX index_name ON table_name(column_name[,column_name…])； 语法解析: 1,unique 指定索引列上的值必须是唯一的 称为 唯一索引（例如 主键） 2，index_name 索引名称 3，table_name 索引作用于的表 4, colunm_name 指定对那个列 进行索引 如果是多个列 就称为 组合索引 删除索引 drop index index_name 3，临时表 创建临时表有两种方式： 1、会话级临时表 on commit preserve rows; 当COMMIT的时候保留数据 2、事务级临时表 on commit delete rows; 当COMMIT的时候删除数据（默认情况） 1.会话级临时表(会话级临时表是指临时表中的数据只在会话生命周期之中存在) 格式: Create Global Temporary Table Temp_Name ( Col1 Type1, Col2 Type2 ... ) On Commit Preserve Rows; eg: create global temporary table temp_tb (col1 varchar(20)) on commit preserve rows; insert into temp_tb values('test'); select * from temp_tb; 2.事务级临时表( 事务级临时表是指临时表中的数据只在事务生命周期中存在) 格式: Create Global Temporary Table Temp_Name ( Col1 Type1, Col2 Type2 ... ) On Commit Delete Rows; 例子 create global temporary table temp_tb (col1 varchar(20)) on commit delete rows; insert into temp_tb values('test'); select * from temp_tb; 4，视图 create or repacle view view_name [with read only] as 语法解析:with read only 加上的话 意为 创建只读视图 查询：select * from v_emp1; select * from v_emp1 where ename like '%M%'; 修改：update v_emp1 set job='销售' where ename='sb'; 添加：insert into v_emp2 values('2222','sb2','技术'); 删除：delete from v_emp2 where empno=2222 5，删除表drop delete truncate 区别 delete：属于DML语句，删除数据库中指定条件的数据，相应语法： DELETE table WHERE a = b; 执行该语句后，需要使用commit进行提交才能反映到数据库中 truncate：（不是trancate）属于DDL语句，快速的删除指定表的所有数据， TRUNCATE在各种表上无论是大的还是小的都非常快，同其它DDL语句一样，都显示的有提交操作，因此，执 行之后是无法进行回滚操作的。TRUNCATE将重新设置高水平线和所有的索引。在对整个表和索引进行完全浏览时，经过TRUNCATE操作后的表比Delete操作后的表要快得多。TRUNCATE不能触发任何Delete触发器。当表被清空后表和表的 索引将重新设置成初始大小，而delete则不能。 语法：TRUNCATE TABLE 表名 drop： 属于DDL语句，作用是删除整个表、删除指定的用户、删除指定的存储空间等等 6，储存过程 Create procedure 存储过程名称 as Begin ... End 存储过程名称； In 只进不出 Out 只出不进 In out 可进可出 eg: create or replace procedure proc1( para1 varchar2, para2 out varchar2, para3 in out varchar2 ) as v_name varchar2(20); begin v_name :='zhangsf'; para3 := v_name; dbms_output.put_line('para3:'||para3); end; 7,游标 create or replace cursor cursor_name as 显示游标 隐式游标的属性 返回值类型 意 义 SQL%ROWCOUNT 整型 代表 DML 语句成功执行的数据行数 SQL%FOUND 布尔型 值为 TRUE 代表插入、删除、更新或单行查询操作成功 SQL%NOTFOUND 布尔型 与 SQL%FOUND 属性返回值相反 SQL%ISOPEN 布尔型 DML 执行过程中为真，结束后为假 动态游标 强类型动态游标 弱类型动态游标 eg： set serverout on; declare cursor cu_emp is select empno,ename,sal from emp; e_no number; e_name varchar2(10); e_sal number; begin open cu_emp; fetch cu_emp into e_no,e_name,e_sal; while cu_emp%found loop dbms_output.put_line('编号：'||e_no||'，姓名：'||e_name||'，基本薪资：'||e_sal); fetch cu_emp into e_no,e_name,e_sal; end loop; close cu_emp; end; set serverout on; declare cursor cu_emp is select empno,ename,sal from emp; e_no emp.empno%type; e_name emp.ename%type; e_sal emp.sal%type; begin open cu_emp; fetch cu_emp into e_no,e_name,e_sal; while cu_emp%found loop dbms_output.put_line('编号：'||e_no||'，姓名：'||e_name||'，基本薪资：'||e_sal); fetch cu_emp into e_no,e_name,e_sal; end loop; close cu_emp; end; set serverout on; declare cursor cu_emp is select * from emp; e emp%rowtype; begin open cu_emp; fetch cu_emp into e; while cu_emp%found loop dbms_output.put_line('编号：'||e.empno||'，姓名：'||e.ename||'，基本薪资：'||e.sal); fetch cu_emp into e; end loop; close cu_emp; end; set serverout on; declare cursor cu_emp is select * from emp where sal>2000 and sal&lt;3000; e emp%rowtype; begin open cu_emp; fetch cu_emp into e; while cu_emp%found loop dbms_output.put_line('编号：'||e.empno||'，姓名：'||e.ename||'，基本薪资：'||e.sal); fetch cu_emp into e; end loop; close cu_emp; end; begin if sql%isopen then dbms_output.put_line('sql游标已打开'); else dbms_output.put_line('sql游标未打开'); end if; end; declare e_count number; begin select count(*) into e_count from emp; dbms_output.put_line('游标捕获的记录数：'||sql%rowcount); end; declare e_count number; begin select count(*) into e_count from emp; dbms_output.put_line('游标捕获的记录数：'||sql%rowcount); end; begin update emp set ename='sb3' where empno=111; if sql%rowcount=1 then dbms_output.put_line('已更新'); else dbms_output.put_line('未更新'); end if; end; begin update emp set ename='sb3' where empno=111; if sql%found then dbms_output.put_line('已更新'); else dbms_output.put_line('未更新'); end if; end; declare type emptype is ref cursor return emp%rowtype; cu_emp emptype; e_count number; e emp%rowtype; begin select count(*) into e_count from emp where job='PRESIDENT1'; if e_count=0 then open cu_emp for select * from emp; else open cu_emp for select * from emp where job='PRESIDENT'; end if; fetch cu_emp into e; while cu_emp%found loop dbms_output.put_line('编号：'||e.empno||'，姓名：'||e.ename||'，基本薪资：'||e.sal); fetch cu_emp into e; end loop; close cu_emp; end; declare type customType is ref cursor; e_count number; e emp%rowtype; s salgrade%rowType; cType customType; begin select count(*) into e_count from emp where job='PRESIDENT1'; if e_count=0 then open cType for select * from salgrade; fetch cType into s; while cType%found loop dbms_output.put_line('等级：'||s.grade||'，最低薪资：'||s.losal||'，最高薪资：'||s.hisal); fetch cType into s; end loop; close cType; else open cType for select * from emp where job='PRESIDENT'; fetch cType into e; while cType%found loop dbms_output.put_line('编号：'||e.empno||'，姓名：'||e.ename||'，基本薪资：'||e.sal); fetch cType into e; end loop; close cType; end if; end; 8,触发器 触发器的禁用和开启 禁用触发器： alter trigger 触发器名称 disable 启用触发器： alter trigger 触发器名称 enable 行触发器针对行记录。 语法结构： Create trigger 触发器名称 Before/after 触发动作 For each row On 作用对象 触发器内置变量 :old :new 语句触发器针对整个表，作用整个表操作； 语法结构： Create trigger 触发器名称 Before/after 触发动作 On 作用对象 触发器谓词：INSERTING、UPDATING、DELETING 9,恢复数据 分为两种方法：scn和时间戳两种方法恢复。 一、通过scn恢复删除且已提交的数据 1、获得当前数据库的scn号 select current_scn from v$database; (切换到sys用户或system用户查询) 查询到的scn号为：1499223 2、查询当前scn号之前的scn select * from 表名 as of scn 1499220; (确定删除的数据是否存在，如果存在，则恢复数据；如果不是，则继续缩小scn号) 3、恢复删除且已提交的数据 flashback table 表名 to scn 1499220; 二、通过时间恢复删除且已提交的数据 1、查询当前系统时间 select to_char(sysdate,'yyyy-mm-dd hh24:mi:ss') from dual; 2、查询删除数据的时间点的数据 select * from 表名 as of timestamp to_timestamp('2013-05-29 15:29:00','yyyy-mm-dd hh24:mi:ss'); (如果不是，则继续缩小范围) 3、恢复删除且已提交的数据 flashback table 表名 to timestamp to_timestamp('2013-05-29 15:29:00','yyyy-mm-dd hh24:mi:ss'); 注意：如果在执行上面的语句，出现错误。可以尝试执行 alter table 表名 enable row movement; //允许更改时间戳 10,导入导出数据 Oracle的备份（是Oracle的版本只能是相邻的，不能垮版本。） 备份方案有：逻辑备份（IMP&amp;EXP命令进行备份）、物理文件备份（脱机及联机备份）、利用RMAN(Recovery Manager)的增量物理文件系统备份。 逻辑备份分为四种模式：表空间备份(tablespace)、表备份(table)、用户备份(user)和完全备份(full)。 exp导出，imp导出命令 -- 全量导出 exp system/manager@TEST file=d:\\daochu.dmp full=y -- 将数据库中system用户与sys用户的表导出 exp system/manager@TEST file=d:\\daochu.dmp owner=(system,sys) -- 将数据库中的表table1中的字段filed1以\"00\"打头的数据导出 exp system/manager@TEST file=d:\\daochu.dmp tables=(table1) query=\\\" where filed1 like '00%'\\\" -- 将数据库中的表table1/table2导出 exp system/manager@TEST file=d:\\daochu.dmp tables=(table1,table2) 导入 imp system/manager@TEST file=d:\\daochu.dmp tables=(table1,table2) 4，将一个用户所属的数据导入另一个用户 imp system/manager file=tank log=tank fromuser=seapark touser=seapark_copy imp system/manager file=tank log=tank fromuser=seapark(table1,table2) touser=seapark_copy(table1,table2); （imp mk/mk file=d:\\daochu.dmp fromuser=mk touser=cyll）（导出 导入的话 要是由执行导出的用户进行导入操作） exp help=y 导入帮助 imp help=y 导出帮助 用户 表空间 --显示 用户下面的所有表 select * from tab; --- 查看用户下面的永久表空间 select default_tablespace from user_users; ---查看临时表空间 和用户状态 select *from user_users --更改用户的 永久表空间 alter user user(操作的用户) default tablespace tablespacename(将要设置的默认表空间名称) --修改 新添加用户的默认表空间 alter database default tablespace tablespaceName --如果默认表空间不存在 则下面有创建表空间的语句 create tablespace tablepaceName datafile datafile size 500m autoextend on; --删除 一个用户 drop user cyll cascade; eg: create tablespace tjsgbb DATAFILE 'tjsgbb.ora' size 500M AUTOEXTEND ON; create user tom identified by cat default tablespace tjsgbb; grant connect to tom; grant resource to tom; grant dba to tom; oracle 用户 Oracle 用户分两种，一种是系统用户 sys system ；另外一种是普通用户； 视图 dba_users 存储着所有用户信息； 创建用户： Create user 用户名 identified by 密码 default tablespace 表空间 授予 session 权限：grant create session to TEST; 锁定和开启帐号：alter user TEST account lock / unlock ; 修改用户密码：alter user TEST identified by 123 ; 删除用户： drop user TEST cascade ; 删除用户，并且把用户下的对象删除，比如表，视图，触发器等。 oracle 权限 Oracle 权限分为系统权限和对象权限； 系统权限是 Oracle 内置的，与具体对象无关的权限，比如创建表的权限，连接数据库权限； 对象权限就是对具体对象，比如表，视图，触发器等的操作权限； 系统权限视图：system_privilege_map 权限分配视图：dba_sys_privs 回收系统权限 revoke 权限 from 用户 对象权限分配 用户表权限视图：dba_tab_privs 给对象授权 grant 权限 on 对象 to 用户 with grant option; 回收权限：revoke 对象权限 on 对象 from 用户；","path":"2018/12/03/oracle-jia-qiang-xue-xi/","date":"12-03","excerpt":""},{"title":"docker 安装 oracle ","text":"1. 安装docker并启动docker服务 sudo yum install docker（安装 docker） sudo systemctl start docker 或者 service docker start 2. 下载oracle-xe-11g镜像sudo docker pull sath89/oracle-xe-11g 下载后执行 sudo docker ps –a 查看本地存在的所有镜像 3. 运行oracle镜像为容器,并将oracle容器的8080 和1521端口映射到本机的8080 和1521端口.sudo docker run -p 8080:8080 -p 1521:1521 --name oracle-xe-11g -d sath89/oracle-xe-11g 在阿里云服务器 上进行的部署 部署完 记得开放相应的端口号 4.启动oracle-xe-11g容器sudo docker start oracle-xe-11g 至此配置完毕 ,浏览器访问localhost:8080/apex 5.登录oracle容器,然后执行sqlplus命令账号,密码 sudo docker exec -it oracle-xe-11g /bin/bash 5.plsql 远程连接 库docker 查看 show parameter service_names 新建的admin目录下创建一个tnsnames.ora的文件，写入文件配置： MyDB= (DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST= xxx.xx.xxx.xxx)(PORT = 1521)) (CONNECT_DATA = (SERVER = DEDICATED) (SERVICE_NAME = xe) ) ) 创建表空间 创建用户 授权操作create tablespace tjsgbb DATAFILE 'tjsgbb.ora' size 500M AUTOEXTEND ON; create user tom identified by cat default tablespace tjsgbb; grant connect to tom; grant resource to tom; grant dba to tom; create yzh identified by nice default tablespace tjsgbb; grant connect to yzh; grant resource to yzh; grant dba to yzh; 可能会用到的命令 docker stop [容器id] docker rm [容器id]","path":"2018/10/31/docker-an-zhuang-oracle/","date":"10-31","excerpt":""},{"title":"崔永元还是输了...","text":"崔永元还是输了大囯魂01这是一个娱乐至死的时代。昨天上午10点，可以支撑逾亿人次同时访问的微博，竟然一时间系统瘫痪。背后的原因，只是因为娱乐圈当红小花赵丽颖发了一条微博。她结婚了，对象是同为娱乐明星的冯绍峰。短短的40多分钟，赵丽颖结婚的微博，转发量就超过了20万次，评论36万条，点赞接近130万。 明星结婚，八方来贺。回想起来，整个10月，充斥我们眼球的范冰冰、张雨绮、李湘……无一例外，都是唱歌演戏的明星。信息爆炸的今天，其实每个人的时间都很有限，每一双眼睛的焦点都很宝贵。给了范冰冰，给了赵丽颖，就给不了那些站在时代的背光面，迎着千军万马，也要逆流而上的真正英雄们。哪有什么岁月静好，不过有人在替你负重前行。正是他们，为我们撑起了一片现世安稳的蓝天，让我们可以怡然自得地嗑着瓜子刷微博，聊着八卦追明星。是的，这也是一个全民健忘的时代。同样是在微博上，爆出范冰冰丑闻，引发娱乐圈地震的孤胆英雄崔永元，发表了一篇文章：《一声长叹一声雷》。整整10天过去了，转发量至今也没突破2万。英雄枯骨无人问，明星家事天下知。这不是时代的悲哀，因为这个时代和过去五千年的每个时代都一样，不知悲欢，不问冷暖。赋予一个时代温度的，是身处其中的人。是你、是我、是他，是你们、是我们、是他们。没错，这就是你我的悲哀，是身处这个时代的每一个人的悲哀。02如果问：21世纪的第一个十年，全中国最火的电视节目是什么？毫无疑问，答案只能是崔永元的《实话实说》。央视纪录片之父陈虻说：中国所有的主持人，没有一个能超过崔永元。崔永元曾经有多火？如果你不清楚，问问你们的父母就知道了。他是当年全中国所有男人的人生偶像，所有女人的梦中情人。但是忽然有一天，身边的人都说他疯了。因为他放着好好的主持人不做，自费100万跑到美国去拍纪录片，跑到微博上怼方舟子，只为了解开转基因背后的真相。一夜之间，他成了“病人崔永元。”人们都说小崔得了抑郁症，精神已经不正常了。可吊诡的是，暗地里一波又一波的神秘说客，却找上了门。他们劝小崔放弃对转基因的调查，封口费高达2亿！背后的真相，不言而喻。2亿是多少？范冰冰偷税漏税那么多年，也才罚了9个亿。崔永元只要动一下嘴皮子，2亿就到手了。可是他没有。他说：“做男人要有骨气，饿死也不答应他们！”骨气，一个多么熟悉的词，一个多么陌生的词。熟悉，是因为我们自小就听过：“富贵不能淫，贫贱不能移，威武不能屈，此之谓大丈夫。”陌生，是因为上一次见到这种骨气，还要回溯到120年前。北京宣武门外的菜市口刑场上，33岁的谭嗣同对着屠刀高喊：我自横刀向天笑，去留肝胆两昆仑。在中国人血液里冷却了120年的骨气，终于在崔永元身上又沸腾了。03故事还没有结束，因为在这个朗朗乾坤下，仍然有数不清的污秽浊流。这一次，崔永元决意以一己之力，单挑整个娱乐圈。一纸阴阳合同，多少影视公司的股价应声跌停，多少光鲜亮丽的明星，露出了丑陋罪恶的真面目。可是还不够，在微博长文《一声叹息一声雷》中，更大的利益集团浮出水面。 崔永元不是病了，他是“疯了”。这个今年已经55岁的“老疯子”，妄想以一人之力，对抗国际巨星，对抗上市公司，对抗世家大族，对抗某局某所……蚍蜉撼树，凭的是一腔孤勇！螳臂挡车，端的是一副肉躯！危险吗？当然危险。崔永元不知道吗？当然知道。 一个连死都不怕的人，真的就无懈可击了吗？不，是人就有软肋。崔永元的软肋，就是他的女儿。她的信息被不法分子公开，她的人身安全岌岌可危。我们无法想象崔永元的内心，经过了何种的天人交战。我们能看见的，只是他在《一声叹息一声雷》里写道：“昨晚，梦见了远在天堂的父亲，他说，记住三个字：不能退。”想起柴静写过的一个关于崔永元的片段：某年央视评论部的年会，他亲自张罗，请了赵本山、郭德纲、罗大佑……年会进行到一半，陆陆续续台下的人有些走了，或是打着手机出去了。最后一个节目，他请来罗大佑。罗大佑一直坐在场下，喝了两瓶酒，一直到11点多上场。大佑也不登台，踩支凳子抱住吉它。一束光，对着话筒说“小崔，不怕，我也抑郁过，不是我们有病，是这个时代有病。”是的，这个时代病了。病在一边是歌舞升平，戏子们浓妆艳抹、粉饰太平，你方唱罢我登场；一边是暗流涌动，孤胆英雄扛着全世界的重量逆流而上，在悬崖边缘举步维艰。而大众的目光，竟然全被明星所吸引，舍不得在英雄的身上多停留片刻。只是，又有多少人还记得那句古训：“大厦将颠，非一木所支也。”04很多人都在问，崔永元最近怎么样了？前两天，崔永元任教的中国传媒大学，传出了一家面馆开业的消息。面馆就开在传媒大学的食堂里，名字叫做“崔永元真面”。面馆不大，菜色也普通，就是市面上常见的重庆小面、牛肉面……可是份量却很足，均价只在10元左右。这个价格在北京这样的一线城市，可以说绝无仅有。因为面馆不为盈利，开设的初衷，就是资助在校的贫困学生。消息传出以后，很多人慕名前往。有人说：吃着吃着，眼泪就禁不住掉进碗里。因为小崔在此时，连个人安危都不保的情况下，还张罗着在学校开个良心面馆，资助贫困学生……总有一种力量，让我们泪流满面。今天，提起崔永元，总是让人想起作家今何在的成名小说《悟空传》。“大圣，此去欲何?”“踏南天，碎凌霄。”“若一去不回？”“便一去不回！”时代需要英雄，英雄需要承担。我们做不到，没关系。但是有人替我们做到了，我们的目光，能不能从灯红酒绿的娱乐圈挪开一会儿，在他们的身上多停留一会儿？为众人抱薪者, 不可使其冻毙于风雪；为自由开路者, 不可使其困顿于荆棘！崔永元的父亲，是一名参加过解放战争和抗美援朝的老兵。他曾在一篇回忆父亲的文章里写道：“小时候很羡慕父亲只要上台讲话，底下就不断有掌声。那时，他的理想就是长大要做一个像父亲这样的人，到台上讲话台下就热烈鼓掌。”成为父亲那样的人，崔永元做到了。给予崔永元掌声，我们做到了吗？ 作者：诗之源链接：https://www.jianshu.com/p/2f836c1ccc16來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","path":"2018/10/31/cui-yong-yuan-huan-shi-shu-liao/","date":"10-31","excerpt":""},{"title":"如何看待 S8 RNG 2:3 G2","text":"从高中开始玩英雄联盟，从高二开始做rng 的粉丝 只想说今天 rng 输给 g2 输的我莫名其妙 我不知道 教练组 在干什么 选的什么英雄 打的也太放飞自我了吧 试问进入8强的队伍 有哪一个是弱队怎么能这就是我们lpl引以为傲的冠军之师吗？被我们口口声声说的欧美捞比赛前口嗨，bp阶段疯狂pickVN嘲讽，赛中被吊起来锤一顿。提几个问题。BP到底在干什么？G2的adc是世界第一adc吗，除了100%胜率的大头还值得给2个ban位？是你uzi打不过，还是对面用韦鲁斯和烬打得你出不了塔，连塔刀都不敢补，对线天然压40刀？以及塔姆这个点。可能头铁是值得骄傲的优点吧。但为什么亚运会KR下路设计的一级团陷阱你们能一直记着，换个塔姆被搞了这么多次还不长记性，非要放出来？是忘了faker教你的5把加里奥，还是觉得欧美队不当人只会口嗨？觉得对手不当人之前，看看你自己是不是人吧 我是真的心疼mlxg。永远都在临危救主，永远接锅就上，可惜今天却捞不动这迷一样的队友和教练组。你尽管膨胀，不吸取教训，明年rng还是这个b样，觉得自己能续杯，结果反向拿个八强游泳回来。 我只想说 没有输给别人 纯粹输给了自己 引用知乎作者：我说海盗才有营养","path":"2018/10/20/ru-he-kan-dai-s8-rng-2-3-g2/","date":"10-20","excerpt":""},{"title":"shell 脚本学习","text":"shell命令 是一种运行在linux系统上的语言 便于直接操作文件脚本的格式 vim shell.sh #!/bin/bash //声明脚本解释器，这个‘#’号不是注释，其余是注释 #Program: //程序内容说明 #History: //时间和作者 shell变量的种类 用户自定义变量：由用户自己定义、修改和使用 与定义变量：Bash与定义的特殊变量，不能直接修改 位置变量：通过命令行给程序传递执行的参数 1、定义变量： 变量名要以英文字母或下划线开头，区分大小写。 格式：变量名=值 输出变量：echo $变量名 2、键盘输入为变量内容： 格式：read [-p “信息”] 变量名 如：read -p “pewase input your name:” name 3、不同引号对变量的作用 双引号””：可解析变量，$符号为变量前缀。 单引号’’：不解析变量，$为普通字符。 反引号：将命令执行的结果输出给变量。 shell 条件测试1、test命令： 用途：测试特定的表达式是否成立，当条件成立时，命令执行后的返回值为0，否则为其他数字。 格式：test 条件表达式 [ 条件表达式 ] (注意：[]与表达式之间存在空格) 2、常见的测试类型： 测试文件状态 格式：[ 操作符 文件或目录 ] 如：if [ -d /etc ] then echo “exists” else echo “not exists” fi 常见的测试操作符： -d:测试是否为目录 -e:测试目录或文件是否存在 -f:测试是否为文件 -r:测试当前用户是否有读权限 -w:测试当前用户是否有写权限 -x:测试当前用户是否有执行权限 -L:测试是否为符号链接文件 字符串比较 格式：[ 字符串1 = 字符串2 ] [ 字符串1 != 字符串2 ] [ -z 字符串 ] 如：read -p ‘name:’ name read -p ‘pass:’ pass if [ $name = ‘admin’ ] &amp;&amp; [ $pass = ‘123’] then echo ‘登录成功’ else echo ‘登录失败’ if 常用的测试操作符： =:字符串内容相同。 !=:字符串内容不同。 -z:字符串内容为空。 整数值比较 格式：[ 整数1 操作符 整数2 ] 如：age=30 if [ $age -ge 18 ] then echo “已成年” else echo “未成年” fi 常用的测试操作符： -eq:等于 -ne:不等于 -gt:大于 -lt:小于 -le:大于或等于 -ge:小于或等于 逻辑测试 格式：[ 表达式1 ] 操作符 [ 表达式2 ] 常用操作符： -a或&amp;&amp;:逻辑与 -o或||:逻辑或 !:逻辑非 流程判断 1、条件判断 a、if语句 格式： 单分支： if 条件表达式 then 命令序列 fi `bash 如：age=30 if [ $age -ge 18 ] then echo “已成年” else echo “未成年” fi 多分枝： if 条件表达式 then 命令序列 elif 命令序列 fi 如： ```bash score=87 if [ $score -lt 60 ];then echo &#39;60以下&#39; elif [ $score -gt 60 ] &amp;&amp; [ $score -lt 70 ];then echo &#39;60~70之间&#39; elif [ $score -ge 70 ] &amp;&amp; [ $score -lt 80 ];then echo &#39;70～ 80之间&#39; else echo &#39;优秀&#39; fi b、case 格式：case $变量名称 in &quot;第一个变量内容&quot;) ;; &quot;第二个变量内容&quot;) ;; *) //最后一个变量内容都会用*来代表其它值，不包含前面的变量内容 ;; esac 如： case $1 in start) echo 'start MYSQL service.' ;; stop) echo 'stop MYSQL service.' ;; *) echo \"Usage: $0 start|stop\" ;; esac 2、循环控制 跳出本次循环：continue 结束循环：break a、while循环 格式：while [ 条件表达式 ] do 程序段落 done 如：num=3 while [ $num -gt 0 ] do echo $num num=$(($num-1)) done b、for循环 格式：for var in con1 con2 con3 do 程序段 done 如： for i in user0 user1 user2 user3 echo $i done 格式：for ((i=0;i&lt;10 1++)) do 程序段 done 如：for ((i=0;i&lt;10;i++)) do echo $i useradd user$i echo 123 | password --stdin_user$i done 3、函数使用 定义一个函数：在程序的最前面 function 函数名(){}或者function 函数名{} 如：function printit(){ echo \"your choice is $1\" } 调用：直接使用函数名 如：printit 1 传递参数：函数名 参数1 参数1 如：printit 2 五、Shell文本操作 1、Find查找命令的使用 find . -name \"*.text\" //在当前目录下查找已txt为后缀的文件 fing .-name \"[a-z]*\" //在当前目录下查找开头字母的文件 find /etc -name \"host*\" //查找/etc目录下以host开头的文件 find . -perm 755 //在当前目录下查找属性为755的文件 find -user root //在当前目录下查找属主为root的文件 find /var -mtime -5 //在/var下查找更改时间在5天内的文件 find /var -mtime +3 //在/var下查找更改时间在3天以前的文件 find /etc -type d //查找文件类型为d的目录文件 find /etc -typt l //查找文件类型为l的链接文件 find . -size +1000000c //查找文件大小在1M的文件 2、正则表达式 ^linux //以linux开头的 $php //以php结尾的 . //匹配任意单字符 .+ //匹配任意多个字符 .* //匹配0个或多个字符 [0-9a-z] //匹配[]内任意一个字符 (linux)+ //出现多次linux单词 (web){2} //web出现了2次以上 \\ //转译 3、grep详解 grep \"li qq\"* //在所有文件中查找li qq文件 grep -c \"file\" a //在文件中查找有多少行匹配到file grep -n \"file\" a //在文件中查找有多少行匹配file，同时显示行和行号 grep -i \"file\" a //在文件中查找file，并不区分大小写 grep -v \"file\" a //在文件中过滤掉file所在的行 grep -E \"2017:22:5[0-9]\" a //在文件中查找在时间在2017:22:50到59的所在行 grep -E \"^[^210]\" a //在文件中查找不号寒210的行 grep -E \"h*p\" a //查找包含h和p的行 grep -E \"[5-8][6-9][0-3]\" a //查找大于560小于893的行 grep -E \"^d\" a //在文件中查找以d开头的行 grep -E \"^[^d]\" a //在文件中查找不是以d开头的行 #### 4、awk命令： 简介：awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。 awk语言的最基本功能是在文件或者字符串中基于指定规则浏览和抽取信息，awk抽取信息后，才能进行其他文本操作。完整的awk脚本通常用来格式化文本文件中的信息。 通常，awk是以文件的一行为处理单位的。awk每接收文件的一行，然后执行相应的命令，来处理文本。 格式：awk ‘{pattern + action}’ {filenames} pattern:查找内容 action:匹配规则 awk ‘{pring $0}’ access.log //查找文件中的每一列 awk ‘{print $1”\\t”$7}’ access.log //查找文件中第一列和第七列 cat file | awk ‘$0 !~ /192.168.31.25/‘|grep “php” //匹配Ip 地址的统计，!~为不匹配 例：for i in `cat /etc/passwd | head | awk -F:'{print $1}'` do echo $i done -F---以什么符号分割 head---去前多少行，默认是10行 5、sed行定位使用 简介：sed是非交互式的编辑器。它不会修改文件，除非使用shell重定向来保存结果。默认情况下，所有的输出行都被打印到屏幕上。 选项 功能 -e 进行多项编辑，即对输入行应用多条sed命令时使用 -n 取消默认的输出 -f 指定sed脚本的文件名`bash sed -n ‘2’p file //只打印第二行，不打印其他行 sed -n ‘1,4’p file //从第一行到第四行的记录 sed -n ‘/los/‘p file //打印匹配los的行 sed -n ‘4,/los/‘p file //打印从第四行到匹配los的之间所有行 sed ‘1,2’d file //吧第一行和第二行全部删除 6、Uniq行定位使用 简介：uniq命令用于报告或忽略文件中的重复行，一般与sort命令结合使用。 语法 uniq(选项)(参数) 选项 ： -c或——count：在每列旁边显示该行重复出现的次数； -d或–repeated：仅显示重复出现的行列； -f&lt;栏位&gt;或–skip-fields=&lt;栏位&gt;：忽略比较指定的栏位； -s&lt;字符位置&gt;或–skip-chars=&lt;字符位置&gt;：忽略比较指定的字符； -u或——unique：仅显示出一次的行列； -w&lt;字符位置&gt;或–check-chars=&lt;字符位置&gt;：指定要比较的字符。 uniq -c file //打印紧挨的重复行出现的次数 uniq -d file //只打印重复的行 awk ‘{print $1}’ /var/log/httpd/access_log | sort|uniq -c //把apache网站的所有访问ip全部统计出来，并打印出统计次数。 7、spli行定位 简介：可以将一个大文件分割成很多个小文件，有时需要将文件分割成更小的片段，比如为提高可读性，生成日志。 语法：split（选项）（file）PREFIX 选项： -b：值为每一输出档案的大小，单位为 byte。 -C：每一输出档中，单行的最大 byte 数。 -d：使用数字作为后缀。 -l：值为每一输出档的列数大小。 PREFIX:代表前导符，可作为切割文件的前导文件。 `","path":"2018/10/15/shell-jiao-ben-xue-xi/","date":"10-15","excerpt":""},{"title":"git 命令 学习","text":"刚开始 初始化 一个 目录的时候 （注意编写文件的时候 选择 其他编辑工具 ue 或者 notepaid 格式选择utf-8） 然后 cd d:/github git init 创建一个叫做 readme.txt 的文件 git add 把文件添加到本地git库 （先进行 add） git commit -m \"wrote a readme file\" (然后进行commit) 可以同时add 多个 然后一次性 commit 然后 修改 一个 readme.txt 文件 git status git diff git add git status https://blog.csdn.net/r8l8q8/article/details/80015330","path":"2018/09/19/git-ming-ling-xue-xi/","date":"09-19","excerpt":""},{"title":"如何发布hexo 的 博客","text":"前言在跟几个同学一起 搭建尝试 用hexo 搭建完博客 之后 又互相商业互呲了 一波 突然 发现自己不知道怎么从头发布一篇博客了有没有 赶紧打开我的 度娘 谷歌 找到了 一篇 知识点 废话 不多说 开始我的表演 ！！！创建 一个 博客 hexo n \"my article\" #完整命令为hexo new,用于新建一篇名为“my article”的文章 Markdown 语法 常用命令一、标题 # 这是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是五级标题 ###### 这是六级标题 一、字体 **这是加粗的文字** *这是倾斜的文字*` ***这是斜体加粗的文字*** ~~这是加删除线的文字~~ 三、引用 &gt;这是引用的内容 &gt;&gt;这是引用的内容 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 这是引用的内容 不信你看 hello beijing hello shanghai 四、分割线 三个或者三个以上的 - 或者 * 都可以。` ### 五、图片 ```java ![图片alt](图片地址 &#39;&#39;图片title&#39;&#39;) 图片alt就是显示在图片下面的文字，相当于对图片内容的解释。 图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 六、超链接 语法: [超链接名](超链接地址 \"超链接title\") title可加可不加 [简书](http://jianshu.com) [百度](http://baidu.com) &lt;a href=\"超链接地址\" target=\"_blank\">超链接名&lt;/a> 例:&lt;a href=\"https://doudouchen.cn\" target=\"_blank\">豆豆陈&lt;/a> 个人博客 七、代码语法： 单行代码：代码之间分别用一个反引号包起来 `代码内容` 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 public static void main (String[] args){ system.out.println(\"hhh\"); } 注意事项在使用代码快的时候 注意要 在 ``` 后边加上 对应的编程 语言 感谢 blinkfox 的指导 Hexo 约有二十个命令，但普通用户经常使用的大概只有下列几个: hexo shexo s 启动本地服务器，用于预览主题。默认地址： http://localhost:4000/ hexo s 是 hexo server 的缩写，命令效果一致； 预览的同时可以修改文章内容或主题代码，保存后刷新页面即可； 对 Hexo 根目录 _config.yml 的修改，需要重启本地服务器后才能预览效果。 hexo newhexo new &quot;学习笔记 六&quot; 新建一篇标题为 学习笔记 六 的文章，因为标题里有空格，所以加上了引号。 文章标题可以在对应 md 文件里改，新建时标题可以写的简单些。 hexo dhexo d 自动生成网站静态文件，并部署到设定的仓库。 hexo d 是 hexo deploy 的缩写，命令效果一致。 hexo cleanhexo clean 清除缓存文件 db.json 和已生成的静态文件 public 。 网站显示异常时可以执行这条命令试试。 hexo ghexo g 生成网站静态文件到默认设置的 public 文件夹。 便于查看网站生成的静态文件或者手动部署网站； 如果使用自动部署，不需要先执行该命令； hexo g 是 hexo generate 的缩写，命令效果一致。 hexo new pagehexo new page aboutme 新建一个标题为 aboutme 的页面，默认链接地址为 主页地址/aboutme/ 标题可以为中文，但一般习惯用英文； 页面标题和文章一样可以随意修改； 页面不会出现在首页文章列表和归档中，也不支持设置分类和标签。 学习于简书 https://www.jianshu.com/p/191d1e21f7ed","path":"2018/09/19/ru-he-fa-bu-hexo-de-bo-ke/","date":"09-19","excerpt":""},{"title":"Docker","text":"Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。 hello docker !!!查看docker版本docker version More info: Writing 显示docker系统的信息docker info 日志信息docker logs 故障检查service docker status 启动关闭docker sudo service docker start|stop","path":"2018/09/11/docker/","date":"09-11","excerpt":""},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. hello hexo !!!Create a new post hexo new \"My New Post\" More info: Writing Run server hexo server More info: Server Generate static files hexo generate 或者 hexo g More info: Generating Deploy to remote sites hexo deploy More info: Deployment","path":"2018/09/10/hello-world/","date":"09-10","excerpt":""}]}