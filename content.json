{"pages":[{"title":"categories","text":"","path":"categories/index.html","date":"10-13","excerpt":""},{"title":"about","text":"","path":"about/index.html","date":"10-13","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"10-13","excerpt":""},{"title":"搜索功能的必须步骤","text":"","path":"搜索功能的必须步骤/index.html","date":"09-10","excerpt":""}],"posts":[{"title":"软件测试","text":"1，测试的划分 单元测试： 单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。 集成测试（也叫组装测试，联合测试）是单元测试的逻辑扩展。它最简单的形式是：把两个已经测试过的单元组合成一个组件，测试它们之间的接口。 系统测试是针对整个产品系统进行的测试，目的是验证系统是否满足了需求规格的定义，找出与需求规格不符或与之矛盾的地方，从而提出更加完善的方案。系统测试发现问题之后要经过调试找出错误原因和位置，然后进行改正。 验收测试是部署软件之前的最后一个测试操作。 2，静态测试和动态测试 静态测试:静态方法是指不运行被测程序本身，仅通过分析或检查源程序的语法、结构、过程、接口等来检查程序的正确性。对需求规格说明书、软件设计说明书、源程序做结构分析、流程图分析、符号执行来找错。 动态测试:实际的执行被测对象的程序代码，输入实现设计好的测试用例，检查程序代码运行得到的结果与测试用例中设计的预期结果之间是否有差异，判定实际结果与预测结果是否一致。 动态测试有四部分组成：设计测试用例，执行测试用例，分析比较输出结果，输出测试报告。 按是否运行程序划分 静态测试 静态方法是指不运行被测程序本身，仅通过分析或检查源程序的语法、结构、过程、接口等来检查程序的正确性。对需求规格说明书、软件设计说明书、源程序做结构分析、流程图分析、符号执行来找错。静态测试结果可用于进一步的查错，并为测试用例选取提供指导。 动态测试 实际的执行被测对象的程序代码，输入实现设计好的测试用例，检查程序代码运行得到的结果与测试用例中设计的预期结果之间是否有差异，判定实际结果与预测结果是否一致。 动态测试有四部分组成：设计测试用例，执行测试用例，分析比较输出结果，输出测试报告。 需求说明书、需求规格说明书 按照是否查看源代码分 白盒测试 基于软件内部设计和程序实现的测试方式。 黑盒测试 基于软件需求，而不是基于软件内部设计和程序实现的测试方式。 黑盒测试—功能测试 Functional testing（功能测试），也称为behavioral testing（行为测试），根据产品特性、操作描述和用户方案，测试一个产品的特性和可操作行为以确定它们满足设计需求。 黑盒测试—性能测试 通常验证软件的性能在正常环境和系统条件下重复使用是否还能满足性能指标同时发现系统中存在的性能瓶颈，起到优化系统的目的。 3,白盒测试和黑盒测试? 白盒测试:基于软件内部设计和程序实现的测试方式 黑盒测试:基于需求设计，不根据软件内部设计和程序实现的测试方法。 4，测试的项目周期 v模型 V模型即包含了底层测试又包含了高层测试； 底层测试：检验源代码质量的测试，如：单元测试。 高层测试：检验整个系统的需要，如：系统测试。 V模型清楚地标识出了软件开发的阶段。 它采用自顶向下逐步求精的方式把整个开发过程分成不同的阶段，每个阶段的工作都很明确，因此便于控制开发过程。当所有的阶段都完成之后，该软件的开发过程也随之结束。 V模型仅仅把测试过程作为在需求分析、概要设计、详细设计以及编码之后的一个阶段，容易使人误解测试是软件开发的最后一个阶段，是软件开发的从属。 V模型的另一个大缺点正是它自身的顺序性所导致的。到了测试阶段，程序已经完成，错误已经产生，很多前期的错误一直到测试阶段才发现，甚至无法发现，往往无从修改了。 同时实际的开发过程中，在需求阶段很难把用户的需求完全明确下来，因此，当需求变更时将会导致阶段反复，而且都要重复需求、设计、编码、测试等过程，返工量非常大，模型灵活性比较低。 V模型仅仅把测试过程作为在需求分析、概要设计、详细设计以及编码之后的一个阶段，容易使人误解测试是软件开发的最后一个阶段，是软件开发的从属。 V模型的另一个大缺点正是它自身的顺序性所导致的。到了测试阶段，程序已经完成，错误已经产生，很多前期的错误一直到测试阶段才发现，甚至无法发现，往往无从修改了。 同时实际的开发过程中，在需求阶段很难把用户的需求完全明确下来，因此，当需求变更时将会导致阶段反复，而且都要重复需求、设计、编码、测试等过程，返工量非常大，模型灵活性比较低。 等价类 划分等价的原则 定义：将输入的数据划分成若干类，从每类选取数据。选取的测试数据的测试结果代表这个类别。 分类： 有效等价类：对于程序来说，是合理的、有意义的数据。 无效等价类：对于程序来说，是不合理的、没有意义的数据。 划分等价类的原则 如果输入条件规定了取值范围或者取值个数，则可以确定一个有效等价类和 两个无效等价类。 如果输入条件规定了输入的集合，或规定了“必须如何”的条件，则可以确 定一个有效等价类和一个无效等价类。 如果输入条件是一个布尔值，可以确定一个有效等价类和一个无效等价类。 如果规定了输入一组n个数据，且程序对每个输入值分别进行处理，则为每一 个输入值确定一个有效等价类，共n个有效等价类，在这组值以外确定一个无效等价类。 如果规定了输入的数据必须遵守的n条规则，则可以确定满足所有需求的一个 有效等价类，和违反每条规则的n条无效等价类。 设计一个新的测试用例，使其尽量多的覆盖已经列出的尚未被覆盖的有效等价类，直到所有的有效等价类都被覆盖为止。 设计一个新的测试用例，使其仅覆盖一个已经列出的尚未被覆盖的无效等价类，重复这一步，直到所有列出的无效等价类都被覆盖为止。 边界值-基础概念 场景法 判定表 因果图 选择题 用逻辑判断来 测试单元的需求分析 描绘单元，分解单元， 单元细化 分析需求测试的原则 完整的 ，正确性 ，一致性 可行性 软件测试中的风险以及风险管理","path":"2018/12/03/ruan-jian-ce-shi/","date":"12-03","excerpt":""},{"title":"Spark-Hadoop、Hive、Spark 之间是什么关系？","text":"作者：Xiaoyu Ma 链接：https://www.zhihu.com/question/27974418/answer/38965760 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 大数据本身是个很宽泛的概念，Hadoop生态圈（或者泛生态圈）基本上都是为了处理超过单机尺度的数据处理而诞生的。你可以把它比作一个厨房所以需要的各种工具。锅碗瓢盆，各有各的用处，互相之间又有重合。你可以用汤锅直接当碗吃饭喝汤，你可以用小刀或者刨子去皮。但是每个工具有自己的特性，虽然奇怪的组合也能工作，但是未必是最佳选择。 大数据，首先你要能存的下大数据。 传统的文件系统是单机的，不能横跨不同的机器。HDFS（Hadoop Distributed FileSystem）的设计本质上是为了大量的数据能横跨成百上千台机器，但是你看到的是一个文件系统而不是很多文件系统。比如你说我要获取/hdfs/tmp/file1的数据，你引用的是一个文件路径，但是实际的数据存放在很多不同的机器上。你作为用户，不需要知道这些，就好比在单机上你不关心文件分散在什么磁道什么扇区一样。HDFS为你管理这些数据。 存的下数据之后，你就开始考虑怎么处理数据。虽然HDFS可以为你整体管理不同机器上的数据，但是这些数据太大了。一台机器读取成T上P的数据（很大的数据哦，比如整个东京热有史以来所有高清电影的大小甚至更大），一台机器慢慢跑也许需要好几天甚至好几周。对于很多公司来说，单机处理是不可忍受的，比如微博要更新24小时热博，它必须在24小时之内跑完这些处理。那么我如果要用很多台机器处理，我就面临了如何分配工作，如果一台机器挂了如何重新启动相应的任务，机器之间如何互相通信交换数据以完成复杂的计算等等。这就是MapReduce / Tez / Spark的功能。MapReduce是第一代计算引擎，Tez和Spark是第二代。MapReduce的设计，采用了很简化的计算模型，只有Map和Reduce两个计算过程（中间用Shuffle串联），用这个模型，已经可以处理大数据领域很大一部分问题了。 那什么是Map什么是Reduce？ 考虑如果你要统计一个巨大的文本文件存储在类似HDFS上，你想要知道这个文本里各个词的出现频率。你启动了一个MapReduce程序。Map阶段，几百台机器同时读取这个文件的各个部分，分别把各自读到的部分分别统计出词频，产生类似 （hello, 12100次），（world，15214次）等等这样的Pair（我这里把Map和Combine放在一起说以便简化）；这几百台机器各自都产生了如上的集合，然后又有几百台机器启动Reduce处理。Reducer机器A将从Mapper机器收到所有以A开头的统计结果，机器B将收到B开头的词汇统计结果（当然实际上不会真的以字母开头做依据，而是用函数产生Hash值以避免数据串化。因为类似X开头的词肯定比其他要少得多，而你不希望数据处理各个机器的工作量相差悬殊）。然后这些Reducer将再次汇总，（hello，12100）＋（hello，12311）＋（hello，345881）= （hello，370292）。每个Reducer都如上处理，你就得到了整个文件的词频结果。 这看似是个很简单的模型，但很多算法都可以用这个模型描述了。 Map＋Reduce的简单模型很黄很暴力，虽然好用，但是很笨重。第二代的Tez和Spark除了内存Cache之类的新feature，本质上来说，是让Map/Reduce模型更通用，让Map和Reduce之间的界限更模糊，数据交换更灵活，更少的磁盘读写，以便更方便地描述复杂算法，取得更高的吞吐量。 有了MapReduce，Tez和Spark之后，程序员发现，MapReduce的程序写起来真麻烦。他们希望简化这个过程。这就好比你有了汇编语言，虽然你几乎什么都能干了，但是你还是觉得繁琐。你希望有个更高层更抽象的语言层来描述算法和数据处理流程。于是就有了Pig和Hive。Pig是接近脚本方式去描述MapReduce，Hive则用的是SQL。它们把脚本和SQL语言翻译成MapReduce程序，丢给计算引擎去计算，而你就从繁琐的MapReduce程序中解脱出来，用更简单更直观的语言去写程序了。 有了Hive之后，人们发现SQL对比Java有巨大的优势。一个是它太容易写了。刚才词频的东西，用SQL描述就只有一两行，MapReduce写起来大约要几十上百行。而更重要的是，非计算机背景的用户终于感受到了爱：我也会写SQL！于是数据分析人员终于从乞求工程师帮忙的窘境解脱出来，工程师也从写奇怪的一次性的处理程序中解脱出来。大家都开心了。Hive逐渐成长成了大数据仓库的核心组件。甚至很多公司的流水线作业集完全是用SQL描述，因为易写易改，一看就懂，容易维护。 自从数据分析人员开始用Hive分析数据之后，它们发现，Hive在MapReduce上跑，真鸡巴慢！流水线作业集也许没啥关系，比如24小时更新的推荐，反正24小时内跑完就算了。但是数据分析，人们总是希望能跑更快一些。比如我希望看过去一个小时内多少人在充气娃娃页面驻足，分别停留了多久，对于一个巨型网站海量数据下，这个处理过程也许要花几十分钟甚至很多小时。而这个分析也许只是你万里长征的第一步，你还要看多少人浏览了跳蛋多少人看了拉赫曼尼诺夫的CD，以便跟老板汇报，我们的用户是猥琐男闷骚女更多还是文艺青年／少女更多。你无法忍受等待的折磨，只能跟帅帅的工程师蝈蝈说，快，快，再快一点！ 于是Impala，Presto，Drill诞生了（当然还有无数非著名的交互SQL引擎，就不一一列举了）。三个系统的核心理念是，MapReduce引擎太慢，因为它太通用，太强壮，太保守，我们SQL需要更轻量，更激进地获取资源，更专门地对SQL做优化，而且不需要那么多容错性保证（因为系统出错了大不了重新启动任务，如果整个处理时间更短的话，比如几分钟之内）。这些系统让用户更快速地处理SQL任务，牺牲了通用性稳定性等特性。如果说MapReduce是大砍刀，砍啥都不怕，那上面三个就是剔骨刀，灵巧锋利，但是不能搞太大太硬的东西。 这些系统，说实话，一直没有达到人们期望的流行度。因为这时候又两个异类被造出来了。他们是Hive on Tez / Spark和SparkSQL。它们的设计理念是，MapReduce慢，但是如果我用新一代通用计算引擎Tez或者Spark来跑SQL，那我就能跑的更快。而且用户不需要维护两套系统。这就好比如果你厨房小，人又懒，对吃的精细程度要求有限，那你可以买个电饭煲，能蒸能煲能烧，省了好多厨具。 上面的介绍，基本就是一个数据仓库的构架了。底层HDFS，上面跑MapReduce／Tez／Spark，在上面跑Hive，Pig。或者HDFS上直接跑Impala，Drill，Presto。这解决了中低速数据处理的要求。 那如果我要更高速的处理呢？ 如果我是一个类似微博的公司，我希望显示不是24小时热博，我想看一个不断变化的热播榜，更新延迟在一分钟之内，上面的手段都将无法胜任。于是又一种计算模型被开发出来，这就是Streaming（流）计算。Storm是最流行的流计算平台。流计算的思路是，如果要达到更实时的更新，我何不在数据流进来的时候就处理了？比如还是词频统计的例子，我的数据流是一个一个的词，我就让他们一边流过我就一边开始统计了。流计算很牛逼，基本无延迟，但是它的短处是，不灵活，你想要统计的东西必须预先知道，毕竟数据流过就没了，你没算的东西就无法补算了。因此它是个很好的东西，但是无法替代上面数据仓库和批处理系统。 还有一个有些独立的模块是KV Store，比如Cassandra，HBase，MongoDB以及很多很多很多很多其他的（多到无法想象）。所以KV Store就是说，我有一堆键值，我能很快速滴获取与这个Key绑定的数据。比如我用身份证号，能取到你的身份数据。这个动作用MapReduce也能完成，但是很可能要扫描整个数据集。而KV Store专用来处理这个操作，所有存和取都专门为此优化了。从几个P的数据中查找一个身份证号，也许只要零点几秒。这让大数据公司的一些专门操作被大大优化了。比如我网页上有个根据订单号查找订单内容的页面，而整个网站的订单数量无法单机数据库存储，我就会考虑用KV Store来存。KV Store的理念是，基本无法处理复杂的计算，大多没法JOIN，也许没法聚合，没有强一致性保证（不同数据分布在不同机器上，你每次读取也许会读到不同的结果，也无法处理类似银行转账那样的强一致性要求的操作）。但是丫就是快。极快。 每个不同的KV Store设计都有不同取舍，有些更快，有些容量更高，有些可以支持更复杂的操作。必有一款适合你。 除此之外，还有一些更特制的系统／组件，比如Mahout是分布式机器学习库，Protobuf是数据交换的编码和库，ZooKeeper是高一致性的分布存取协同系统，等等。 有了这么多乱七八糟的工具，都在同一个集群上运转，大家需要互相尊重有序工作。所以另外一个重要组件是，调度系统。现在最流行的是Yarn。你可以把他看作中央管理，好比你妈在厨房监工，哎，你妹妹切菜切完了，你可以把刀拿去杀鸡了。只要大家都服从你妈分配，那大家都能愉快滴烧菜。 你可以认为，大数据生态圈就是一个厨房工具生态圈。为了做不同的菜，中国菜，日本菜，法国菜，你需要各种不同的工具。而且客人的需求正在复杂化，你的厨具不断被发明，也没有一个万用的厨具可以处理所有情况，因此它会变的越来越复杂。","path":"2018/12/03/spark-hadoop-hive-spark-zhi-jian-shi-shi-me-guan-xi/","date":"12-03","excerpt":""},{"title":"ORACLE 加强学习","text":"本次知识点1,掌握 oracle中把一张表中的数据复制到另一张表中去 2,oraclhe中创建索引 3, oracle中临时表的创建 4,oracle中创建视图 5,oracle中删除drop truncate delete 的区别 6,oracle中创建储存过程 7,oracle中创建游标 8,oracle中创建触发器 9,oracle 中的 恢复 表数据 10,oracle 中的导入导出操作 1，复制表001，如果没有表结构创建表结构 CREATE TABLE 新表 AS SELECT * FROM 旧表 WHERE 1=2; 002，向新表中复制数据 insert into 新表 select * from 旧表; 003，同一个表中 将表中的a字段的值 赋给 b字段 update 表名set A=B; 2，索引CREATE [UNIQUE] INDEX index_name ON table_name(column_name[,column_name…])； 语法解析: 1,unique 指定索引列上的值必须是唯一的 称为 唯一索引（例如 主键） 2，index_name 索引名称 3，table_name 索引作用于的表 4, colunm_name 指定对那个列 进行索引 如果是多个列 就称为 组合索引 删除索引 drop index index_name 3，临时表 创建临时表有两种方式： 1、会话级临时表 on commit preserve rows; 当COMMIT的时候保留数据 2、事务级临时表 on commit delete rows; 当COMMIT的时候删除数据（默认情况） 1.会话级临时表(会话级临时表是指临时表中的数据只在会话生命周期之中存在) 格式: Create Global Temporary Table Temp_Name ( Col1 Type1, Col2 Type2 ... ) On Commit Preserve Rows; eg: create global temporary table temp_tb (col1 varchar(20)) on commit preserve rows; insert into temp_tb values('test'); select * from temp_tb; 2.事务级临时表( 事务级临时表是指临时表中的数据只在事务生命周期中存在) 格式: Create Global Temporary Table Temp_Name ( Col1 Type1, Col2 Type2 ... ) On Commit Delete Rows; 例子 create global temporary table temp_tb (col1 varchar(20)) on commit delete rows; insert into temp_tb values('test'); select * from temp_tb; 4，视图 create or repacle view view_name [with read only] as 语法解析:with read only 加上的话 意为 创建只读视图 查询：select * from v_emp1; select * from v_emp1 where ename like '%M%'; 修改：update v_emp1 set job='销售' where ename='sb'; 添加：insert into v_emp2 values('2222','sb2','技术'); 删除：delete from v_emp2 where empno=2222 5，删除表drop delete truncate 区别 delete：属于DML语句，删除数据库中指定条件的数据，相应语法： DELETE table WHERE a = b; 执行该语句后，需要使用commit进行提交才能反映到数据库中 truncate：（不是trancate）属于DDL语句，快速的删除指定表的所有数据， TRUNCATE在各种表上无论是大的还是小的都非常快，同其它DDL语句一样，都显示的有提交操作，因此，执 行之后是无法进行回滚操作的。TRUNCATE将重新设置高水平线和所有的索引。在对整个表和索引进行完全浏览时，经过TRUNCATE操作后的表比Delete操作后的表要快得多。TRUNCATE不能触发任何Delete触发器。当表被清空后表和表的 索引将重新设置成初始大小，而delete则不能。 语法：TRUNCATE TABLE 表名 drop： 属于DDL语句，作用是删除整个表、删除指定的用户、删除指定的存储空间等等 6，储存过程 Create procedure 存储过程名称 as Begin ... End 存储过程名称； In 只进不出 Out 只出不进 In out 可进可出 eg: create or replace procedure proc1( para1 varchar2, para2 out varchar2, para3 in out varchar2 ) as v_name varchar2(20); begin v_name :='zhangsf'; para3 := v_name; dbms_output.put_line('para3:'||para3); end; 7,游标 create or replace cursor cursor_name as 显示游标 隐式游标的属性 返回值类型 意 义 SQL%ROWCOUNT 整型 代表 DML 语句成功执行的数据行数 SQL%FOUND 布尔型 值为 TRUE 代表插入、删除、更新或单行查询操作成功 SQL%NOTFOUND 布尔型 与 SQL%FOUND 属性返回值相反 SQL%ISOPEN 布尔型 DML 执行过程中为真，结束后为假 动态游标 强类型动态游标 弱类型动态游标 eg： set serverout on; declare cursor cu_emp is select empno,ename,sal from emp; e_no number; e_name varchar2(10); e_sal number; begin open cu_emp; fetch cu_emp into e_no,e_name,e_sal; while cu_emp%found loop dbms_output.put_line('编号：'||e_no||'，姓名：'||e_name||'，基本薪资：'||e_sal); fetch cu_emp into e_no,e_name,e_sal; end loop; close cu_emp; end; set serverout on; declare cursor cu_emp is select empno,ename,sal from emp; e_no emp.empno%type; e_name emp.ename%type; e_sal emp.sal%type; begin open cu_emp; fetch cu_emp into e_no,e_name,e_sal; while cu_emp%found loop dbms_output.put_line('编号：'||e_no||'，姓名：'||e_name||'，基本薪资：'||e_sal); fetch cu_emp into e_no,e_name,e_sal; end loop; close cu_emp; end; set serverout on; declare cursor cu_emp is select * from emp; e emp%rowtype; begin open cu_emp; fetch cu_emp into e; while cu_emp%found loop dbms_output.put_line('编号：'||e.empno||'，姓名：'||e.ename||'，基本薪资：'||e.sal); fetch cu_emp into e; end loop; close cu_emp; end; set serverout on; declare cursor cu_emp is select * from emp where sal>2000 and sal&lt;3000; e emp%rowtype; begin open cu_emp; fetch cu_emp into e; while cu_emp%found loop dbms_output.put_line('编号：'||e.empno||'，姓名：'||e.ename||'，基本薪资：'||e.sal); fetch cu_emp into e; end loop; close cu_emp; end; begin if sql%isopen then dbms_output.put_line('sql游标已打开'); else dbms_output.put_line('sql游标未打开'); end if; end; declare e_count number; begin select count(*) into e_count from emp; dbms_output.put_line('游标捕获的记录数：'||sql%rowcount); end; declare e_count number; begin select count(*) into e_count from emp; dbms_output.put_line('游标捕获的记录数：'||sql%rowcount); end; begin update emp set ename='sb3' where empno=111; if sql%rowcount=1 then dbms_output.put_line('已更新'); else dbms_output.put_line('未更新'); end if; end; begin update emp set ename='sb3' where empno=111; if sql%found then dbms_output.put_line('已更新'); else dbms_output.put_line('未更新'); end if; end; declare type emptype is ref cursor return emp%rowtype; cu_emp emptype; e_count number; e emp%rowtype; begin select count(*) into e_count from emp where job='PRESIDENT1'; if e_count=0 then open cu_emp for select * from emp; else open cu_emp for select * from emp where job='PRESIDENT'; end if; fetch cu_emp into e; while cu_emp%found loop dbms_output.put_line('编号：'||e.empno||'，姓名：'||e.ename||'，基本薪资：'||e.sal); fetch cu_emp into e; end loop; close cu_emp; end; declare type customType is ref cursor; e_count number; e emp%rowtype; s salgrade%rowType; cType customType; begin select count(*) into e_count from emp where job='PRESIDENT1'; if e_count=0 then open cType for select * from salgrade; fetch cType into s; while cType%found loop dbms_output.put_line('等级：'||s.grade||'，最低薪资：'||s.losal||'，最高薪资：'||s.hisal); fetch cType into s; end loop; close cType; else open cType for select * from emp where job='PRESIDENT'; fetch cType into e; while cType%found loop dbms_output.put_line('编号：'||e.empno||'，姓名：'||e.ename||'，基本薪资：'||e.sal); fetch cType into e; end loop; close cType; end if; end; 8,触发器 触发器的禁用和开启 禁用触发器： alter trigger 触发器名称 disable 启用触发器： alter trigger 触发器名称 enable 行触发器针对行记录。 语法结构： Create trigger 触发器名称 Before/after 触发动作 For each row On 作用对象 触发器内置变量 :old :new 语句触发器针对整个表，作用整个表操作； 语法结构： Create trigger 触发器名称 Before/after 触发动作 On 作用对象 触发器谓词：INSERTING、UPDATING、DELETING 9,恢复数据 分为两种方法：scn和时间戳两种方法恢复。 一、通过scn恢复删除且已提交的数据 1、获得当前数据库的scn号 select current_scn from v$database; (切换到sys用户或system用户查询) 查询到的scn号为：1499223 2、查询当前scn号之前的scn select * from 表名 as of scn 1499220; (确定删除的数据是否存在，如果存在，则恢复数据；如果不是，则继续缩小scn号) 3、恢复删除且已提交的数据 flashback table 表名 to scn 1499220; 二、通过时间恢复删除且已提交的数据 1、查询当前系统时间 select to_char(sysdate,'yyyy-mm-dd hh24:mi:ss') from dual; 2、查询删除数据的时间点的数据 select * from 表名 as of timestamp to_timestamp('2013-05-29 15:29:00','yyyy-mm-dd hh24:mi:ss'); (如果不是，则继续缩小范围) 3、恢复删除且已提交的数据 flashback table 表名 to timestamp to_timestamp('2013-05-29 15:29:00','yyyy-mm-dd hh24:mi:ss'); 注意：如果在执行上面的语句，出现错误。可以尝试执行 alter table 表名 enable row movement; //允许更改时间戳 10,导入导出数据 Oracle的备份（是Oracle的版本只能是相邻的，不能垮版本。） 备份方案有：逻辑备份（IMP&amp;EXP命令进行备份）、物理文件备份（脱机及联机备份）、利用RMAN(Recovery Manager)的增量物理文件系统备份。 逻辑备份分为四种模式：表空间备份(tablespace)、表备份(table)、用户备份(user)和完全备份(full)。 exp导出，imp导出命令 -- 全量导出 exp system/manager@TEST file=d:\\daochu.dmp full=y -- 将数据库中system用户与sys用户的表导出 exp system/manager@TEST file=d:\\daochu.dmp owner=(system,sys) -- 将数据库中的表table1中的字段filed1以\"00\"打头的数据导出 exp system/manager@TEST file=d:\\daochu.dmp tables=(table1) query=\\\" where filed1 like '00%'\\\" -- 将数据库中的表table1/table2导出 exp system/manager@TEST file=d:\\daochu.dmp tables=(table1,table2) 导入 imp system/manager@TEST file=d:\\daochu.dmp tables=(table1,table2) 4，将一个用户所属的数据导入另一个用户 imp system/manager file=tank log=tank fromuser=seapark touser=seapark_copy imp system/manager file=tank log=tank fromuser=seapark(table1,table2) touser=seapark_copy(table1,table2); （imp mk/mk file=d:\\daochu.dmp fromuser=mk touser=cyll）（导出 导入的话 要是由执行导出的用户进行导入操作） exp help=y 导入帮助 imp help=y 导出帮助 用户 表空间 --显示 用户下面的所有表 select * from tab; --- 查看用户下面的永久表空间 select default_tablespace from user_users; ---查看临时表空间 和用户状态 select *from user_users --更改用户的 永久表空间 alter user user(操作的用户) default tablespace tablespacename(将要设置的默认表空间名称) --修改 新添加用户的默认表空间 alter database default tablespace tablespaceName --如果默认表空间不存在 则下面有创建表空间的语句 create tablespace tablepaceName datafile datafile size 500m autoextend on; --删除 一个用户 drop user cyll cascade; eg: create tablespace tjsgbb DATAFILE 'tjsgbb.ora' size 500M AUTOEXTEND ON; create user tom identified by cat default tablespace tjsgbb; grant connect to tom; grant resource to tom; grant dba to tom; oracle 用户 Oracle 用户分两种，一种是系统用户 sys system ；另外一种是普通用户； 视图 dba_users 存储着所有用户信息； 创建用户： Create user 用户名 identified by 密码 default tablespace 表空间 授予 session 权限：grant create session to TEST; 锁定和开启帐号：alter user TEST account lock / unlock ; 修改用户密码：alter user TEST identified by 123 ; 删除用户： drop user TEST cascade ; 删除用户，并且把用户下的对象删除，比如表，视图，触发器等。 oracle 权限 Oracle 权限分为系统权限和对象权限； 系统权限是 Oracle 内置的，与具体对象无关的权限，比如创建表的权限，连接数据库权限； 对象权限就是对具体对象，比如表，视图，触发器等的操作权限； 系统权限视图：system_privilege_map 权限分配视图：dba_sys_privs 回收系统权限 revoke 权限 from 用户 对象权限分配 用户表权限视图：dba_tab_privs 给对象授权 grant 权限 on 对象 to 用户 with grant option; 回收权限：revoke 对象权限 on 对象 from 用户；","path":"2018/12/03/oracle-jia-qiang-xue-xi/","date":"12-03","excerpt":""},{"title":"docker 安装 oracle ","text":"1. 安装docker并启动docker服务 sudo yum install docker（安装 docker） sudo systemctl start docker 或者 service docker start 2. 下载oracle-xe-11g镜像sudo docker pull sath89/oracle-xe-11g 下载后执行 sudo docker ps –a 查看本地存在的所有镜像 3. 运行oracle镜像为容器,并将oracle容器的8080 和1521端口映射到本机的8080 和1521端口.sudo docker run -p 8080:8080 -p 1521:1521 --name oracle-xe-11g -d sath89/oracle-xe-11g 在阿里云服务器 上进行的部署 部署完 记得开放相应的端口号 4.启动oracle-xe-11g容器sudo docker start oracle-xe-11g 至此配置完毕 ,浏览器访问localhost:8080/apex 5.登录oracle容器,然后执行sqlplus命令账号,密码 sudo docker exec -it oracle-xe-11g /bin/bash 5.plsql 远程连接 库docker 查看 show parameter service_names 新建的admin目录下创建一个tnsnames.ora的文件，写入文件配置： MyDB= (DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST= xxx.xx.xxx.xxx)(PORT = 1521)) (CONNECT_DATA = (SERVER = DEDICATED) (SERVICE_NAME = xe) ) ) 创建表空间 创建用户 授权操作create tablespace tjsgbb DATAFILE 'tjsgbb.ora' size 500M AUTOEXTEND ON; create user tom identified by cat default tablespace tjsgbb; grant connect to tom; grant resource to tom; grant dba to tom; create yzh identified by nice default tablespace tjsgbb; grant connect to yzh; grant resource to yzh; grant dba to yzh; 可能会用到的命令 docker stop [容器id] docker rm [容器id]","path":"2018/10/31/docker-an-zhuang-oracle/","date":"10-31","excerpt":""},{"title":"崔永元还是输了...","text":"崔永元还是输了大囯魂01这是一个娱乐至死的时代。昨天上午10点，可以支撑逾亿人次同时访问的微博，竟然一时间系统瘫痪。背后的原因，只是因为娱乐圈当红小花赵丽颖发了一条微博。她结婚了，对象是同为娱乐明星的冯绍峰。短短的40多分钟，赵丽颖结婚的微博，转发量就超过了20万次，评论36万条，点赞接近130万。 明星结婚，八方来贺。回想起来，整个10月，充斥我们眼球的范冰冰、张雨绮、李湘……无一例外，都是唱歌演戏的明星。信息爆炸的今天，其实每个人的时间都很有限，每一双眼睛的焦点都很宝贵。给了范冰冰，给了赵丽颖，就给不了那些站在时代的背光面，迎着千军万马，也要逆流而上的真正英雄们。哪有什么岁月静好，不过有人在替你负重前行。正是他们，为我们撑起了一片现世安稳的蓝天，让我们可以怡然自得地嗑着瓜子刷微博，聊着八卦追明星。是的，这也是一个全民健忘的时代。同样是在微博上，爆出范冰冰丑闻，引发娱乐圈地震的孤胆英雄崔永元，发表了一篇文章：《一声长叹一声雷》。整整10天过去了，转发量至今也没突破2万。英雄枯骨无人问，明星家事天下知。这不是时代的悲哀，因为这个时代和过去五千年的每个时代都一样，不知悲欢，不问冷暖。赋予一个时代温度的，是身处其中的人。是你、是我、是他，是你们、是我们、是他们。没错，这就是你我的悲哀，是身处这个时代的每一个人的悲哀。02如果问：21世纪的第一个十年，全中国最火的电视节目是什么？毫无疑问，答案只能是崔永元的《实话实说》。央视纪录片之父陈虻说：中国所有的主持人，没有一个能超过崔永元。崔永元曾经有多火？如果你不清楚，问问你们的父母就知道了。他是当年全中国所有男人的人生偶像，所有女人的梦中情人。但是忽然有一天，身边的人都说他疯了。因为他放着好好的主持人不做，自费100万跑到美国去拍纪录片，跑到微博上怼方舟子，只为了解开转基因背后的真相。一夜之间，他成了“病人崔永元。”人们都说小崔得了抑郁症，精神已经不正常了。可吊诡的是，暗地里一波又一波的神秘说客，却找上了门。他们劝小崔放弃对转基因的调查，封口费高达2亿！背后的真相，不言而喻。2亿是多少？范冰冰偷税漏税那么多年，也才罚了9个亿。崔永元只要动一下嘴皮子，2亿就到手了。可是他没有。他说：“做男人要有骨气，饿死也不答应他们！”骨气，一个多么熟悉的词，一个多么陌生的词。熟悉，是因为我们自小就听过：“富贵不能淫，贫贱不能移，威武不能屈，此之谓大丈夫。”陌生，是因为上一次见到这种骨气，还要回溯到120年前。北京宣武门外的菜市口刑场上，33岁的谭嗣同对着屠刀高喊：我自横刀向天笑，去留肝胆两昆仑。在中国人血液里冷却了120年的骨气，终于在崔永元身上又沸腾了。03故事还没有结束，因为在这个朗朗乾坤下，仍然有数不清的污秽浊流。这一次，崔永元决意以一己之力，单挑整个娱乐圈。一纸阴阳合同，多少影视公司的股价应声跌停，多少光鲜亮丽的明星，露出了丑陋罪恶的真面目。可是还不够，在微博长文《一声叹息一声雷》中，更大的利益集团浮出水面。 崔永元不是病了，他是“疯了”。这个今年已经55岁的“老疯子”，妄想以一人之力，对抗国际巨星，对抗上市公司，对抗世家大族，对抗某局某所……蚍蜉撼树，凭的是一腔孤勇！螳臂挡车，端的是一副肉躯！危险吗？当然危险。崔永元不知道吗？当然知道。 一个连死都不怕的人，真的就无懈可击了吗？不，是人就有软肋。崔永元的软肋，就是他的女儿。她的信息被不法分子公开，她的人身安全岌岌可危。我们无法想象崔永元的内心，经过了何种的天人交战。我们能看见的，只是他在《一声叹息一声雷》里写道：“昨晚，梦见了远在天堂的父亲，他说，记住三个字：不能退。”想起柴静写过的一个关于崔永元的片段：某年央视评论部的年会，他亲自张罗，请了赵本山、郭德纲、罗大佑……年会进行到一半，陆陆续续台下的人有些走了，或是打着手机出去了。最后一个节目，他请来罗大佑。罗大佑一直坐在场下，喝了两瓶酒，一直到11点多上场。大佑也不登台，踩支凳子抱住吉它。一束光，对着话筒说“小崔，不怕，我也抑郁过，不是我们有病，是这个时代有病。”是的，这个时代病了。病在一边是歌舞升平，戏子们浓妆艳抹、粉饰太平，你方唱罢我登场；一边是暗流涌动，孤胆英雄扛着全世界的重量逆流而上，在悬崖边缘举步维艰。而大众的目光，竟然全被明星所吸引，舍不得在英雄的身上多停留片刻。只是，又有多少人还记得那句古训：“大厦将颠，非一木所支也。”04很多人都在问，崔永元最近怎么样了？前两天，崔永元任教的中国传媒大学，传出了一家面馆开业的消息。面馆就开在传媒大学的食堂里，名字叫做“崔永元真面”。面馆不大，菜色也普通，就是市面上常见的重庆小面、牛肉面……可是份量却很足，均价只在10元左右。这个价格在北京这样的一线城市，可以说绝无仅有。因为面馆不为盈利，开设的初衷，就是资助在校的贫困学生。消息传出以后，很多人慕名前往。有人说：吃着吃着，眼泪就禁不住掉进碗里。因为小崔在此时，连个人安危都不保的情况下，还张罗着在学校开个良心面馆，资助贫困学生……总有一种力量，让我们泪流满面。今天，提起崔永元，总是让人想起作家今何在的成名小说《悟空传》。“大圣，此去欲何?”“踏南天，碎凌霄。”“若一去不回？”“便一去不回！”时代需要英雄，英雄需要承担。我们做不到，没关系。但是有人替我们做到了，我们的目光，能不能从灯红酒绿的娱乐圈挪开一会儿，在他们的身上多停留一会儿？为众人抱薪者, 不可使其冻毙于风雪；为自由开路者, 不可使其困顿于荆棘！崔永元的父亲，是一名参加过解放战争和抗美援朝的老兵。他曾在一篇回忆父亲的文章里写道：“小时候很羡慕父亲只要上台讲话，底下就不断有掌声。那时，他的理想就是长大要做一个像父亲这样的人，到台上讲话台下就热烈鼓掌。”成为父亲那样的人，崔永元做到了。给予崔永元掌声，我们做到了吗？ 作者：诗之源链接：https://www.jianshu.com/p/2f836c1ccc16來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","path":"2018/10/31/cui-yong-yuan-huan-shi-shu-liao/","date":"10-31","excerpt":""},{"title":"如何看待 S8 RNG 2:3 G2","text":"从高中开始玩英雄联盟，从高二开始做rng 的粉丝 只想说今天 rng 输给 g2 输的我莫名其妙 我不知道 教练组 在干什么 选的什么英雄 打的也太放飞自我了吧 试问进入8强的队伍 有哪一个是弱队怎么能这就是我们lpl引以为傲的冠军之师吗？被我们口口声声说的欧美捞比赛前口嗨，bp阶段疯狂pickVN嘲讽，赛中被吊起来锤一顿。提几个问题。BP到底在干什么？G2的adc是世界第一adc吗，除了100%胜率的大头还值得给2个ban位？是你uzi打不过，还是对面用韦鲁斯和烬打得你出不了塔，连塔刀都不敢补，对线天然压40刀？以及塔姆这个点。可能头铁是值得骄傲的优点吧。但为什么亚运会KR下路设计的一级团陷阱你们能一直记着，换个塔姆被搞了这么多次还不长记性，非要放出来？是忘了faker教你的5把加里奥，还是觉得欧美队不当人只会口嗨？觉得对手不当人之前，看看你自己是不是人吧 我是真的心疼mlxg。永远都在临危救主，永远接锅就上，可惜今天却捞不动这迷一样的队友和教练组。你尽管膨胀，不吸取教训，明年rng还是这个b样，觉得自己能续杯，结果反向拿个八强游泳回来。 我只想说 没有输给别人 纯粹输给了自己 引用知乎作者：我说海盗才有营养","path":"2018/10/20/ru-he-kan-dai-s8-rng-2-3-g2/","date":"10-20","excerpt":""},{"title":"shell 脚本学习","text":"shell命令 是一种运行在linux系统上的语言 便于直接操作文件脚本的格式 vim shell.sh #!/bin/bash //声明脚本解释器，这个‘#’号不是注释，其余是注释 #Program: //程序内容说明 #History: //时间和作者 shell变量的种类 用户自定义变量：由用户自己定义、修改和使用 与定义变量：Bash与定义的特殊变量，不能直接修改 位置变量：通过命令行给程序传递执行的参数 1、定义变量： 变量名要以英文字母或下划线开头，区分大小写。 格式：变量名=值 输出变量：echo $变量名 2、键盘输入为变量内容： 格式：read [-p “信息”] 变量名 如：read -p “pewase input your name:” name 3、不同引号对变量的作用 双引号””：可解析变量，$符号为变量前缀。 单引号’’：不解析变量，$为普通字符。 反引号：将命令执行的结果输出给变量。 shell 条件测试1、test命令： 用途：测试特定的表达式是否成立，当条件成立时，命令执行后的返回值为0，否则为其他数字。 格式：test 条件表达式 [ 条件表达式 ] (注意：[]与表达式之间存在空格) 2、常见的测试类型： 测试文件状态 格式：[ 操作符 文件或目录 ] 如：if [ -d /etc ] then echo “exists” else echo “not exists” fi 常见的测试操作符： -d:测试是否为目录 -e:测试目录或文件是否存在 -f:测试是否为文件 -r:测试当前用户是否有读权限 -w:测试当前用户是否有写权限 -x:测试当前用户是否有执行权限 -L:测试是否为符号链接文件 字符串比较 格式：[ 字符串1 = 字符串2 ] [ 字符串1 != 字符串2 ] [ -z 字符串 ] 如：read -p ‘name:’ name read -p ‘pass:’ pass if [ $name = ‘admin’ ] &amp;&amp; [ $pass = ‘123’] then echo ‘登录成功’ else echo ‘登录失败’ if 常用的测试操作符： =:字符串内容相同。 !=:字符串内容不同。 -z:字符串内容为空。 整数值比较 格式：[ 整数1 操作符 整数2 ] 如：age=30 if [ $age -ge 18 ] then echo “已成年” else echo “未成年” fi 常用的测试操作符： -eq:等于 -ne:不等于 -gt:大于 -lt:小于 -le:大于或等于 -ge:小于或等于 逻辑测试 格式：[ 表达式1 ] 操作符 [ 表达式2 ] 常用操作符： -a或&amp;&amp;:逻辑与 -o或||:逻辑或 !:逻辑非 流程判断 1、条件判断 a、if语句 格式： 单分支： if 条件表达式 then 命令序列 fi `bash 如：age=30 if [ $age -ge 18 ] then echo “已成年” else echo “未成年” fi 多分枝： if 条件表达式 then 命令序列 elif 命令序列 fi 如： ```bash score=87 if [ $score -lt 60 ];then echo &#39;60以下&#39; elif [ $score -gt 60 ] &amp;&amp; [ $score -lt 70 ];then echo &#39;60~70之间&#39; elif [ $score -ge 70 ] &amp;&amp; [ $score -lt 80 ];then echo &#39;70～ 80之间&#39; else echo &#39;优秀&#39; fi b、case 格式：case $变量名称 in &quot;第一个变量内容&quot;) ;; &quot;第二个变量内容&quot;) ;; *) //最后一个变量内容都会用*来代表其它值，不包含前面的变量内容 ;; esac 如： case $1 in start) echo 'start MYSQL service.' ;; stop) echo 'stop MYSQL service.' ;; *) echo \"Usage: $0 start|stop\" ;; esac 2、循环控制 跳出本次循环：continue 结束循环：break a、while循环 格式：while [ 条件表达式 ] do 程序段落 done 如：num=3 while [ $num -gt 0 ] do echo $num num=$(($num-1)) done b、for循环 格式：for var in con1 con2 con3 do 程序段 done 如： for i in user0 user1 user2 user3 echo $i done 格式：for ((i=0;i&lt;10 1++)) do 程序段 done 如：for ((i=0;i&lt;10;i++)) do echo $i useradd user$i echo 123 | password --stdin_user$i done 3、函数使用 定义一个函数：在程序的最前面 function 函数名(){}或者function 函数名{} 如：function printit(){ echo \"your choice is $1\" } 调用：直接使用函数名 如：printit 1 传递参数：函数名 参数1 参数1 如：printit 2 五、Shell文本操作 1、Find查找命令的使用 find . -name \"*.text\" //在当前目录下查找已txt为后缀的文件 fing .-name \"[a-z]*\" //在当前目录下查找开头字母的文件 find /etc -name \"host*\" //查找/etc目录下以host开头的文件 find . -perm 755 //在当前目录下查找属性为755的文件 find -user root //在当前目录下查找属主为root的文件 find /var -mtime -5 //在/var下查找更改时间在5天内的文件 find /var -mtime +3 //在/var下查找更改时间在3天以前的文件 find /etc -type d //查找文件类型为d的目录文件 find /etc -typt l //查找文件类型为l的链接文件 find . -size +1000000c //查找文件大小在1M的文件 2、正则表达式 ^linux //以linux开头的 $php //以php结尾的 . //匹配任意单字符 .+ //匹配任意多个字符 .* //匹配0个或多个字符 [0-9a-z] //匹配[]内任意一个字符 (linux)+ //出现多次linux单词 (web){2} //web出现了2次以上 \\ //转译 3、grep详解 grep \"li qq\"* //在所有文件中查找li qq文件 grep -c \"file\" a //在文件中查找有多少行匹配到file grep -n \"file\" a //在文件中查找有多少行匹配file，同时显示行和行号 grep -i \"file\" a //在文件中查找file，并不区分大小写 grep -v \"file\" a //在文件中过滤掉file所在的行 grep -E \"2017:22:5[0-9]\" a //在文件中查找在时间在2017:22:50到59的所在行 grep -E \"^[^210]\" a //在文件中查找不号寒210的行 grep -E \"h*p\" a //查找包含h和p的行 grep -E \"[5-8][6-9][0-3]\" a //查找大于560小于893的行 grep -E \"^d\" a //在文件中查找以d开头的行 grep -E \"^[^d]\" a //在文件中查找不是以d开头的行 #### 4、awk命令： 简介：awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。 awk语言的最基本功能是在文件或者字符串中基于指定规则浏览和抽取信息，awk抽取信息后，才能进行其他文本操作。完整的awk脚本通常用来格式化文本文件中的信息。 通常，awk是以文件的一行为处理单位的。awk每接收文件的一行，然后执行相应的命令，来处理文本。 格式：awk ‘{pattern + action}’ {filenames} pattern:查找内容 action:匹配规则 awk ‘{pring $0}’ access.log //查找文件中的每一列 awk ‘{print $1”\\t”$7}’ access.log //查找文件中第一列和第七列 cat file | awk ‘$0 !~ /192.168.31.25/‘|grep “php” //匹配Ip 地址的统计，!~为不匹配 例：for i in `cat /etc/passwd | head | awk -F:'{print $1}'` do echo $i done -F---以什么符号分割 head---去前多少行，默认是10行 5、sed行定位使用 简介：sed是非交互式的编辑器。它不会修改文件，除非使用shell重定向来保存结果。默认情况下，所有的输出行都被打印到屏幕上。 选项 功能 -e 进行多项编辑，即对输入行应用多条sed命令时使用 -n 取消默认的输出 -f 指定sed脚本的文件名`bash sed -n ‘2’p file //只打印第二行，不打印其他行 sed -n ‘1,4’p file //从第一行到第四行的记录 sed -n ‘/los/‘p file //打印匹配los的行 sed -n ‘4,/los/‘p file //打印从第四行到匹配los的之间所有行 sed ‘1,2’d file //吧第一行和第二行全部删除 6、Uniq行定位使用 简介：uniq命令用于报告或忽略文件中的重复行，一般与sort命令结合使用。 语法 uniq(选项)(参数) 选项 ： -c或——count：在每列旁边显示该行重复出现的次数； -d或–repeated：仅显示重复出现的行列； -f&lt;栏位&gt;或–skip-fields=&lt;栏位&gt;：忽略比较指定的栏位； -s&lt;字符位置&gt;或–skip-chars=&lt;字符位置&gt;：忽略比较指定的字符； -u或——unique：仅显示出一次的行列； -w&lt;字符位置&gt;或–check-chars=&lt;字符位置&gt;：指定要比较的字符。 uniq -c file //打印紧挨的重复行出现的次数 uniq -d file //只打印重复的行 awk ‘{print $1}’ /var/log/httpd/access_log | sort|uniq -c //把apache网站的所有访问ip全部统计出来，并打印出统计次数。 7、spli行定位 简介：可以将一个大文件分割成很多个小文件，有时需要将文件分割成更小的片段，比如为提高可读性，生成日志。 语法：split（选项）（file）PREFIX 选项： -b：值为每一输出档案的大小，单位为 byte。 -C：每一输出档中，单行的最大 byte 数。 -d：使用数字作为后缀。 -l：值为每一输出档的列数大小。 PREFIX:代表前导符，可作为切割文件的前导文件。 `","path":"2018/10/15/shell-jiao-ben-xue-xi/","date":"10-15","excerpt":""},{"title":"git 命令 学习","text":"刚开始 初始化 一个 目录的时候 （注意编写文件的时候 选择 其他编辑工具 ue 或者 notepaid 格式选择utf-8） 然后 cd d:/github git init 创建一个叫做 readme.txt 的文件 git add 把文件添加到本地git库 （先进行 add） git commit -m \"wrote a readme file\" (然后进行commit) 可以同时add 多个 然后一次性 commit 然后 修改 一个 readme.txt 文件 git status git diff git add git status https://blog.csdn.net/r8l8q8/article/details/80015330","path":"2018/09/19/git-ming-ling-xue-xi/","date":"09-19","excerpt":""},{"title":"如何发布hexo 的 博客","text":"前言在跟几个同学一起 搭建尝试 用hexo 搭建完博客 之后 又互相商业互呲了 一波 突然 发现自己不知道怎么从头发布一篇博客了有没有 赶紧打开我的 度娘 谷歌 找到了 一篇 知识点 废话 不多说 开始我的表演 ！！！创建 一个 博客 hexo n \"my article\" #完整命令为hexo new,用于新建一篇名为“my article”的文章 Markdown 语法 常用命令一、标题 # 这是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是五级标题 ###### 这是六级标题 一、字体 **这是加粗的文字** *这是倾斜的文字*` ***这是斜体加粗的文字*** ~~这是加删除线的文字~~ 三、引用 &gt;这是引用的内容 &gt;&gt;这是引用的内容 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 这是引用的内容 不信你看 hello beijing hello shanghai 四、分割线 三个或者三个以上的 - 或者 * 都可以。` ### 五、图片 ```java ![图片alt](图片地址 &#39;&#39;图片title&#39;&#39;) 图片alt就是显示在图片下面的文字，相当于对图片内容的解释。 图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 六、超链接 语法: [超链接名](超链接地址 \"超链接title\") title可加可不加 [简书](http://jianshu.com) [百度](http://baidu.com) &lt;a href=\"超链接地址\" target=\"_blank\">超链接名&lt;/a> 例:&lt;a href=\"https://doudouchen.cn\" target=\"_blank\">豆豆陈&lt;/a> 个人博客 七、代码语法： 单行代码：代码之间分别用一个反引号包起来 `代码内容` 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 public static void main (String[] args){ system.out.println(\"hhh\"); } 注意事项在使用代码快的时候 注意要 在 ``` 后边加上 对应的编程 语言 感谢 blinkfox 的指导 Hexo 约有二十个命令，但普通用户经常使用的大概只有下列几个: hexo shexo s 启动本地服务器，用于预览主题。默认地址： http://localhost:4000/ hexo s 是 hexo server 的缩写，命令效果一致； 预览的同时可以修改文章内容或主题代码，保存后刷新页面即可； 对 Hexo 根目录 _config.yml 的修改，需要重启本地服务器后才能预览效果。 hexo newhexo new &quot;学习笔记 六&quot; 新建一篇标题为 学习笔记 六 的文章，因为标题里有空格，所以加上了引号。 文章标题可以在对应 md 文件里改，新建时标题可以写的简单些。 hexo dhexo d 自动生成网站静态文件，并部署到设定的仓库。 hexo d 是 hexo deploy 的缩写，命令效果一致。 hexo cleanhexo clean 清除缓存文件 db.json 和已生成的静态文件 public 。 网站显示异常时可以执行这条命令试试。 hexo ghexo g 生成网站静态文件到默认设置的 public 文件夹。 便于查看网站生成的静态文件或者手动部署网站； 如果使用自动部署，不需要先执行该命令； hexo g 是 hexo generate 的缩写，命令效果一致。 hexo new pagehexo new page aboutme 新建一个标题为 aboutme 的页面，默认链接地址为 主页地址/aboutme/ 标题可以为中文，但一般习惯用英文； 页面标题和文章一样可以随意修改； 页面不会出现在首页文章列表和归档中，也不支持设置分类和标签。 学习于简书 https://www.jianshu.com/p/191d1e21f7ed","path":"2018/09/19/ru-he-fa-bu-hexo-de-bo-ke/","date":"09-19","excerpt":""},{"title":"Docker","text":"Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。 hello docker !!!查看docker版本docker version More info: Writing 显示docker系统的信息docker info 日志信息docker logs 故障检查service docker status 启动关闭docker sudo service docker start|stop","path":"2018/09/11/docker/","date":"09-11","excerpt":""},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. hello hexo !!!Create a new post hexo new \"My New Post\" More info: Writing Run server hexo server More info: Server Generate static files hexo generate 或者 hexo g More info: Generating Deploy to remote sites hexo deploy More info: Deployment","path":"2018/09/10/hello-world/","date":"09-10","excerpt":""}]}